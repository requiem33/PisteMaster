# PisteMasterå‰ç«¯æ¶æ„è®¾è®¡æ–‡æ¡£

## ğŸ¯ é¡¹ç›®æ¦‚è¿°

PisteMasteræ˜¯ä¸€æ¬¾é¢å‘å‡»å‰‘æ¯”èµ›ç¼–æ’çš„ä¸“ä¸šè½¯ä»¶ï¼Œæ¶µç›–èµ›äº‹ç®¡ç†ã€å®æ—¶è®¡åˆ†ã€è£åˆ¤è°ƒåº¦ç­‰åŠŸèƒ½ã€‚æœ¬å‰ç«¯æ¶æ„é’ˆå¯¹**ä½“è‚²èµ›äº‹ç°åœºç¯å¢ƒ**çš„ç‰¹æ®Šéœ€æ±‚è¿›è¡Œäº†æ·±åº¦ä¼˜åŒ–ã€‚

## ğŸ“¦ æŠ€æœ¯æ ˆé€‰å‹

### æ ¸å¿ƒæ¡†æ¶
- **Vue 3.4+** + **TypeScript 5.0+** + **Composition API**
- **Vite 5.0+** - æ„å»ºå·¥å…·ï¼Œæ”¯æŒMPAå¤šå…¥å£
- **Pinia 2.1+** - çŠ¶æ€ç®¡ç†ï¼Œæ”¯æŒæ’ä»¶æ‰©å±•
- **Vue Router 4.2+** - è·¯ç”±ç®¡ç†

### UIç»„ä»¶
- **Element Plus 2.3+** - ç®¡ç†ç«¯UIåº“
- **Naive UI 2.38+** - å¯é€‰ï¼Œæä¾›æ›´ç°ä»£çš„ç»„ä»¶
- **è‡ªå®šä¹‰è£åˆ¤ç«¯UI** - æ‰‹å†™å¤§è§¦æ§ç»„ä»¶

### æ•°æ®ä¸çŠ¶æ€
- **TanStack Query (Vue Query) 5.0+** - æœåŠ¡å™¨çŠ¶æ€ç®¡ç†
- **Yjs 13.6+** - CRDTå®æ—¶ååŒ
- **IndexedDB** + **idb 8.0+** - å®¢æˆ·ç«¯æ•°æ®åº“

### ç¡¬ä»¶äº¤äº’
- **Web Serial API** - ä¸²å£è®¾å¤‡é€šä¿¡
- **Web Bluetooth API** - è“ç‰™è®¾å¤‡è¿æ¥
- **Web Audio API** - ç²¾ç¡®éŸ³é¢‘æ§åˆ¶
- **WebRTC** - å¯é€‰ï¼Œç”¨äºè§†é¢‘è£åˆ¤ç³»ç»Ÿ

### å¯è§†åŒ–ä¸è¡¨æ ¼
- **ECharts 5.4+** + **Vue-ECharts 6.6+** - æ•°æ®å¯è§†åŒ–
- **ag-Grid Community 31.1+** - ä¸“ä¸šçº§æ•°æ®è¡¨æ ¼
- **d3.js 7.8+** - é«˜çº§è‡ªå®šä¹‰å¯è§†åŒ–

### ç¦»çº¿ä¸PWA
- **vite-plugin-pwa 0.19+** - PWAæ”¯æŒ
- **Workbox 7.0+** - Service Workerç®¡ç†
- **localforage 1.10+** - ç®€åŒ–IndexedDBæ“ä½œ

### æ‰“å°ä¸å¯¼å‡º
- **jspdf 2.5+** + **jspdf-autotable 3.5+** - PDFç”Ÿæˆ
- **html2canvas 1.4+** - DOMè½¬å›¾ç‰‡
- **print-js 1.6+** - ç®€åŒ–æ‰“å°

### å›½é™…åŒ–
- **vue-i18n 9.4+** - å¤šè¯­è¨€æ”¯æŒ
- **cldr-core 43.0+** - å›½é™…åŒ–æ•°æ®

### å¼€å‘å·¥å…·
- **Vitest 1.0+** - å•å…ƒæµ‹è¯•
- **Playwright 1.40+** - E2Eæµ‹è¯•
- **ESLint 8.56+** + **Prettier 3.1+** - ä»£ç è§„èŒƒ
- **Sentry 7.81+** - é”™è¯¯ç›‘æ§

## ğŸ—ï¸ é¡¹ç›®æ¶æ„è®¾è®¡

### å¤šå…¥å£æ„å»ºæ¶æ„

```
pistemaster-frontend/
â”œâ”€â”€ packages/                    # Monorepoç»“æ„
â”‚   â”œâ”€â”€ admin-app/              # ç®¡ç†ç«¯åº”ç”¨
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â””â”€â”€ package.json
â”‚   â”œâ”€â”€ display-app/            # å…¬å…±æ˜¾ç¤ºç«¯åº”ç”¨
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â””â”€â”€ package.json
â”‚   â”œâ”€â”€ referee-app/            # è£åˆ¤ç«¯åº”ç”¨ï¼ˆç§»åŠ¨ä¼˜å…ˆï¼‰
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â””â”€â”€ package.json
â”‚   â””â”€â”€ ui-kit/                 # å…±äº«UIç»„ä»¶åº“
â”‚       â”œâ”€â”€ components/
â”‚       â””â”€â”€ package.json
â”œâ”€â”€ shared/                     # å…±äº«ä»£ç 
â”‚   â”œâ”€â”€ types/                  # TypeScriptç±»å‹å®šä¹‰
â”‚   â”œâ”€â”€ utils/                  # é€šç”¨å·¥å…·å‡½æ•°
â”‚   â””â”€â”€ constants/              # å¸¸é‡å®šä¹‰
â””â”€â”€ package.json
```

### ç®¡ç†ç«¯æ ¸å¿ƒæ¶æ„ (admin-app)

```
admin-app/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ api/                    # APIå±‚
â”‚   â”‚   â”œâ”€â”€ http/              # HTTPå®¢æˆ·ç«¯
â”‚   â”‚   â”œâ”€â”€ websocket/         # WebSocketæœåŠ¡
â”‚   â”‚   â”œâ”€â”€ hardware/          # ç¡¬ä»¶API
â”‚   â”‚   â””â”€â”€ services/          # APIæœåŠ¡
â”‚   â”œâ”€â”€ assets/                # é™æ€èµ„æº
â”‚   â”œâ”€â”€ components/            # ä¸šåŠ¡ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ tournament/        # èµ›äº‹ç®¡ç†ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ bracket/           # å¯¹é˜µè¡¨ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ scoring/           # è®¡åˆ†ç»„ä»¶
â”‚   â”‚   â””â”€â”€ printing/          # æ‰“å°ç»„ä»¶
â”‚   â”œâ”€â”€ composables/           # Compositionå‡½æ•°
â”‚   â”œâ”€â”€ hardware/              # ç¡¬ä»¶äº¤äº’å±‚
â”‚   â”‚   â”œâ”€â”€ serial/            # ä¸²å£é€šä¿¡
â”‚   â”‚   â”‚   â”œâ”€â”€ FaveroProtocol.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ STMProtocol.ts
â”‚   â”‚   â”‚   â””â”€â”€ SGProtocol.ts
â”‚   â”‚   â”œâ”€â”€ bluetooth/         # è“ç‰™é€šä¿¡
â”‚   â”‚   â”œâ”€â”€ audio/             # éŸ³é¢‘ç®¡ç†
â”‚   â”‚   â””â”€â”€ middleware/        # ç¡¬ä»¶ä¸­é—´ä»¶
â”‚   â”œâ”€â”€ layouts/               # å¸ƒå±€ç»„ä»¶
â”‚   â”œâ”€â”€ locales/               # å›½é™…åŒ–
â”‚   â”‚   â”œâ”€â”€ fr.ts              # æ³•è¯­ï¼ˆå‡»å‰‘å®˜æ–¹è¯­è¨€ï¼‰
â”‚   â”‚   â”œâ”€â”€ en.ts
â”‚   â”‚   â”œâ”€â”€ zh.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ printing/              # æ‰“å°å¼•æ“
â”‚   â”‚   â”œâ”€â”€ generators/        # ç”Ÿæˆå™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ BracketGenerator.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ ScoreSheetGenerator.ts
â”‚   â”‚   â”‚   â””â”€â”€ CertificateGenerator.ts
â”‚   â”‚   â”œâ”€â”€ templates/         # æ¨¡æ¿
â”‚   â”‚   â””â”€â”€ queue/             # æ‰“å°é˜Ÿåˆ—
â”‚   â”œâ”€â”€ router/                # è·¯ç”±
â”‚   â”œâ”€â”€ stores/                # PiniaçŠ¶æ€
â”‚   â”‚   â”œâ”€â”€ tournament.store.ts
â”‚   â”‚   â”œâ”€â”€ hardware.store.ts
â”‚   â”‚   â”œâ”€â”€ offline.store.ts
â”‚   â”‚   â””â”€â”€ audit.store.ts     # å®¡è®¡æ—¥å¿—
â”‚   â”œâ”€â”€ types/                 # ç±»å‹å®šä¹‰
â”‚   â”œâ”€â”€ utils/                 # å·¥å…·å‡½æ•°
â”‚   â”‚   â”œâ”€â”€ calculations/      # è®¡ç®—å·¥å…·
â”‚   â”‚   â”œâ”€â”€ formatters/        # æ ¼å¼åŒ–
â”‚   â”‚   â”œâ”€â”€ validators/        # éªŒè¯
â”‚   â”‚   â””â”€â”€ helpers/           # åŠ©æ‰‹å‡½æ•°
â”‚   â”œâ”€â”€ views/                 # é¡µé¢è§†å›¾
â”‚   â”œâ”€â”€ workers/               # Web Workers
â”‚   â”‚   â”œâ”€â”€ DataSyncWorker.ts  # æ•°æ®åŒæ­¥
â”‚   â”‚   â”œâ”€â”€ PDFWorker.ts       # PDFç”Ÿæˆ
â”‚   â”‚   â””â”€â”€ CalculationWorker.ts # å¤æ‚è®¡ç®—
â”‚   â””â”€â”€ App.vue
```

## ğŸ”Œ ç¡¬ä»¶äº¤äº’å±‚è¯¦ç»†è®¾è®¡

### 1. ä¸²å£é€šä¿¡ç®¡ç†å™¨

```typescript
// hardware/serial/SerialManager.ts
export class SerialManager {
  private port: SerialPort | null = null;
  private reader: ReadableStreamDefaultReader | null = null;
  private decoder = new TextDecoderStream();
  private parsers = new Map<string, ProtocolParser>();

  constructor() {
    // æ³¨å†Œåè®®è§£æå™¨
    this.parsers.set('FAVERO', new FaveroParser());
    this.parsers.set('STM', new STMParser());
    this.parsers.set('SG', new SGParser());
  }

  async connect(options: SerialOptions = { baudRate: 9600 }) {
    try {
      // è¯·æ±‚ä¸²å£è®¿é—®æƒé™
      this.port = await navigator.serial.requestPort();
      await this.port.open(options);
      
      // å¼€å§‹è¯»å–æ•°æ®
      this.startReading();
      
      // ç›‘å¬è®¾å¤‡æ–­å¼€
      this.port.addEventListener('disconnect', () => {
        this.handleDisconnect();
      });
      
      return { success: true, port: this.port };
    } catch (error) {
      console.error('ä¸²å£è¿æ¥å¤±è´¥:', error);
      return { success: false, error };
    }
  }

  private async startReading() {
    if (!this.port?.readable) return;
    
    const readableStreamClosed = this.port.readable.pipeTo(this.decoder.writable);
    this.reader = this.decoder.readable.getReader();

    try {
      while (true) {
        const { value, done } = await this.reader.read();
        if (done) break;
        
        // è§£ææ•°æ®å¸§
        const frames = this.splitFrames(value);
        for (const frame of frames) {
          const parsed = this.parseFrame(frame);
          if (parsed) {
            // å‘å¸ƒç¡¬ä»¶äº‹ä»¶
            this.emitHardwareEvent(parsed);
          }
        }
      }
    } catch (error) {
      console.error('æ•°æ®è¯»å–é”™è¯¯:', error);
    }
  }

  private parseFrame(frame: string): HardwareEvent | null {
    // å°è¯•æ‰€æœ‰æ³¨å†Œçš„è§£æå™¨
    for (const [name, parser] of this.parsers) {
      try {
        const event = parser.parse(frame);
        if (event) {
          event.metadata.parser = name;
          return event;
        }
      } catch (e) {
        // è¯¥è§£æå™¨æ— æ³•è§£ææ­¤å¸§ï¼Œç»§ç»­å°è¯•ä¸‹ä¸€ä¸ª
        continue;
      }
    }
    return null;
  }

  private emitHardwareEvent(event: HardwareEvent) {
    // ä½¿ç”¨è‡ªå®šä¹‰äº‹ä»¶ç³»ç»Ÿ
    window.dispatchEvent(
      new CustomEvent('hardware:data', { detail: event })
    );
    
    // æ›´æ–°PiniaçŠ¶æ€
    const hardwareStore = useHardwareStore();
    hardwareStore.updateDeviceData(event);
  }
}
```

### 2. åè®®è§£æå™¨æ¥å£

```typescript
// hardware/serial/ProtocolParser.ts
export interface HardwareEvent {
  type: 'SCORE' | 'TIME' | 'CARD' | 'EQUIPMENT' | 'ERROR';
  data: {
    piste?: number;
    leftScore?: number;
    rightScore?: number;
    timeRemaining?: number;
    cardType?: 'YELLOW' | 'RED' | 'BLACK';
    equipmentFault?: 'MASK' | 'LAME' | 'BODY' | 'WEAPON';
  };
  timestamp: number;
  metadata: {
    parser: string;
    rawData: string;
  };
}

export abstract class ProtocolParser {
  abstract parse(rawData: string): HardwareEvent | null;
  
  protected validateChecksum(data: string, checksum: string): boolean {
    // é€šç”¨æ ¡éªŒå’ŒéªŒè¯
    const calculated = this.calculateChecksum(data);
    return calculated === checksum;
  }
  
  protected calculateChecksum(data: string): string {
    // å®ç°æ ¡éªŒå’Œè®¡ç®—
    let sum = 0;
    for (let i = 0; i < data.length; i++) {
      sum += data.charCodeAt(i);
    }
    return (sum & 0xFF).toString(16).padStart(2, '0').toUpperCase();
  }
}

// Faveroåè®®è§£æå™¨å®ç°
export class FaveroParser extends ProtocolParser {
  parse(rawData: string): HardwareEvent | null {
    // Faveroåè®®æ ¼å¼: STX(02h) DATA ETX(03h) BCC
    if (!rawData.startsWith('\x02') || !rawData.endsWith('\x03')) {
      return null;
    }
    
    const data = rawData.slice(1, -2);
    const checksum = rawData.slice(-2);
    
    if (!this.validateChecksum(data, checksum)) {
      return { type: 'ERROR', data: {}, timestamp: Date.now(), metadata: { parser: 'FAVERO', rawData } };
    }
    
    // è§£æå…·ä½“æ•°æ®
    const eventType = data.charCodeAt(0);
    switch (eventType) {
      case 0x41: // Score update
        return {
          type: 'SCORE',
          data: {
            leftScore: data.charCodeAt(1),
            rightScore: data.charCodeAt(2),
            piste: data.charCodeAt(3)
          },
          timestamp: Date.now(),
          metadata: { parser: 'FAVERO', rawData }
        };
      case 0x54: // Time update
        return {
          type: 'TIME',
          data: {
            timeRemaining: this.parseTime(data.slice(1))
          },
          timestamp: Date.now(),
          metadata: { parser: 'FAVERO', rawData }
        };
      default:
        return null;
    }
  }
}
```

### 3. éŸ³é¢‘ç®¡ç†å™¨

```typescript
// hardware/audio/AudioManager.ts
export class AudioManager {
  private context: AudioContext;
  private sounds = new Map<string, AudioBuffer>();
  
  constructor() {
    this.context = new AudioContext();
    this.preloadSounds();
  }
  
  private async preloadSounds() {
    const soundDefinitions = [
      { key: 'score', url: '/sounds/score.wav' },
      { key: 'card', url: '/sounds/card.wav' },
      { key: 'halte', url: '/sounds/halte.wav' },
      { key: 'allez', url: '/sounds/allez.wav' },
      { key: 'pret', url: '/sounds/pret.wav' },
      { key: 'en-garde', url: '/sounds/en-garde.wav' },
      { key: 'end-match', url: '/sounds/end-match.wav' },
      { key: 'countdown-beep', url: '/sounds/countdown-beep.wav' },
    ];
    
    for (const def of soundDefinitions) {
      const buffer = await this.loadSound(def.url);
      this.sounds.set(def.key, buffer);
    }
  }
  
  async playSound(name: string, options: PlayOptions = {}) {
    const buffer = this.sounds.get(name);
    if (!buffer) return;
    
    const source = this.context.createBufferSource();
    source.buffer = buffer;
    
    // é…ç½®æ’­æ”¾å‚æ•°
    if (options.volume !== undefined) {
      const gainNode = this.context.createGain();
      gainNode.gain.value = options.volume;
      source.connect(gainNode);
      gainNode.connect(this.context.destination);
    } else {
      source.connect(this.context.destination);
    }
    
    if (options.detune) {
      source.detune.value = options.detune;
    }
    
    source.start();
    
    // æŒ¯åŠ¨åé¦ˆï¼ˆç§»åŠ¨è®¾å¤‡ï¼‰
    if (options.vibrate && 'vibrate' in navigator) {
      navigator.vibrate([50, 30, 50]);
    }
  }
  
  // ç²¾ç¡®è®¡æ—¶éŸ³é¢‘ï¼ˆç”¨äºå€’è®¡æ—¶ï¼‰
  async playCountdown(seconds: number) {
    // æå‰0.5ç§’é¢„åŠ è½½ï¼Œç¡®ä¿å‡†æ—¶æ’­æ”¾
    const beepBuffer = this.sounds.get('countdown-beep')!;
    
    const scheduleBeep = (time: number) => {
      const source = this.context.createBufferSource();
      source.buffer = beepBuffer;
      source.connect(this.context.destination);
      source.start(time);
    };
    
    const startTime = this.context.currentTime + 0.5;
    for (let i = 0; i < seconds; i++) {
      scheduleBeep(startTime + i);
    }
  }
}
```

## ğŸ”„ ç¦»çº¿ä¸åŒæ­¥æ¶æ„

### 1. ç¦»çº¿æ•°æ®ç®¡ç†å™¨

```typescript
// stores/offline.store.ts
export const useOfflineStore = defineStore('offline', () => {
  const isOnline = ref(navigator.onLine);
  const pendingOperations = ref<PendingOperation[]>([]);
  const syncQueue = ref<SyncQueueItem[]>([]);
  
  const db = localforage.createInstance({
    name: 'PisteMasterOffline',
    storeName: 'operations'
  });
  
  // ç›‘å¬ç½‘ç»œçŠ¶æ€
  window.addEventListener('online', () => {
    isOnline.value = true;
    triggerSync();
  });
  
  window.addEventListener('offline', () => {
    isOnline.value = false;
  });
  
  // æ·»åŠ ç¦»çº¿æ“ä½œ
  const addOperation = async (operation: PendingOperation) => {
    const id = uuidv4();
    const opWithId = {
      ...operation,
      id,
      createdAt: Date.now(),
      attempts: 0,
      lastAttempt: null
    };
    
    // å­˜å‚¨åˆ°IndexedDB
    await db.setItem(id, opWithId);
    pendingOperations.value.push(opWithId);
    
    // å¦‚æœæ˜¯å…³é”®æ“ä½œï¼Œç«‹å³å°è¯•åŒæ­¥
    if (operation.priority === 'high' && isOnline.value) {
      await syncOperation(opWithId);
    }
  };
  
  // åŒæ­¥ç®¡ç†å™¨
  const syncOperation = async (operation: PendingOperation) => {
    try {
      // æ ¹æ®æ“ä½œç±»å‹è°ƒç”¨ä¸åŒçš„API
      switch (operation.type) {
        case 'SCORE_UPDATE':
          await scoreService.update(operation.data.matchId, operation.data.score);
          break;
        case 'CARD_ISSUED':
          await matchService.issueCard(operation.data);
          break;
        // ... å…¶ä»–æ“ä½œç±»å‹
      }
      
      // åŒæ­¥æˆåŠŸï¼Œä»é˜Ÿåˆ—ç§»é™¤
      await db.removeItem(operation.id);
      pendingOperations.value = pendingOperations.value.filter(op => op.id !== operation.id);
      
    } catch (error) {
      // åŒæ­¥å¤±è´¥ï¼Œé‡è¯•é€»è¾‘
      operation.attempts += 1;
      operation.lastAttempt = Date.now();
      operation.lastError = error.message;
      
      // æ›´æ–°å­˜å‚¨
      await db.setItem(operation.id, operation);
      
      // æ ¹æ®é‡è¯•ç­–ç•¥å†³å®šæ˜¯å¦ç»§ç»­
      if (operation.attempts < operation.maxRetries) {
        const delay = Math.min(1000 * Math.pow(2, operation.attempts), 30000);
        setTimeout(() => syncOperation(operation), delay);
      } else {
        // è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œæ ‡è®°ä¸ºå¤±è´¥
        console.error('æ“ä½œåŒæ­¥å¤±è´¥:', operation);
      }
    }
  };
  
  // æ‰¹é‡åŒæ­¥
  const triggerSync = async () => {
    if (!isOnline.value) return;
    
    // ä»IndexedDBåŠ è½½æ‰€æœ‰å¾…å¤„ç†æ“ä½œ
    const operations: PendingOperation[] = [];
    await db.iterate((value: PendingOperation) => {
      operations.push(value);
    });
    
    // æŒ‰ä¼˜å…ˆçº§æ’åº
    operations.sort((a, b) => {
      const priorityOrder = { high: 0, medium: 1, low: 2 };
      return priorityOrder[a.priority] - priorityOrder[b.priority];
    });
    
    // å¹¶å‘åŒæ­¥ï¼ˆæœ€å¤š3ä¸ªåŒæ—¶ï¼‰
    const concurrency = 3;
    for (let i = 0; i < operations.length; i += concurrency) {
      const batch = operations.slice(i, i + concurrency);
      await Promise.allSettled(batch.map(op => syncOperation(op)));
    }
  };
  
  return {
    isOnline,
    pendingOperations,
    addOperation,
    triggerSync
  };
});
```

### 2. CRDTå®æ—¶ååŒ

```typescript
// utils/crdt/CRDTManager.ts
import * as Y from 'yjs';
import { WebsocketProvider } from 'y-websocket';

export class CRDTManager {
  private doc: Y.Doc;
  private providers = new Map<string, WebsocketProvider>();
  private awareness: any;
  
  constructor() {
    this.doc = new Y.Doc();
    this.awareness = this.doc.getMap('awareness');
  }
  
  // ä¸ºæ¯ä¸ªæ¯”èµ›åˆ›å»ºä¸€ä¸ªååŒæ–‡æ¡£
  connectToMatch(matchId: string) {
    const provider = new WebsocketProvider(
      'wss://crdt.pistemaster.com',
      `match-${matchId}`,
      this.doc
    );
    
    this.providers.set(matchId, provider);
    
    // ç›‘å¬è¿œç¨‹æ›´æ–°
    provider.on('sync', (isSynced: boolean) => {
      if (isSynced) {
        console.log(`Match ${matchId} æ•°æ®å·²åŒæ­¥`);
      }
    });
    
    // ç”¨æˆ·çŠ¶æ€ï¼ˆåœ¨çº¿/ç¦»çº¿ã€å…‰æ ‡ä½ç½®ç­‰ï¼‰
    this.awareness.set('user', {
      name: localStorage.getItem('username'),
      color: this.getRandomColor(),
      cursor: null
    });
    
    return provider;
  }
  
  // è·å–æ¯”èµ›æ•°æ®ï¼ˆè‡ªåŠ¨åˆå¹¶å†²çªï¼‰
  getMatchData(matchId: string): MatchData {
    const matchMap = this.doc.getMap(`match-${matchId}`);
    return matchMap.toJSON() as MatchData;
  }
  
  // æ›´æ–°æ¯”èµ›æ•°æ®ï¼ˆè‡ªåŠ¨è§£å†³å†²çªï¼‰
  updateMatchData(matchId: string, updates: Partial<MatchData>) {
    const matchMap = this.doc.getMap(`match-${matchId}`);
    
    // ä½¿ç”¨Yjsçš„äº‹åŠ¡ï¼Œç¡®ä¿åŸå­æ€§
    this.doc.transact(() => {
      Object.entries(updates).forEach(([key, value]) => {
        if (value !== undefined) {
          matchMap.set(key, value);
        }
      });
    });
  }
  
  // å¤„ç†ç¦»çº¿æœŸé—´çš„æœ¬åœ°æ›´æ”¹
  async applyLocalChanges(matchId: string, localChanges: any[]) {
    const provider = this.providers.get(matchId);
    if (!provider) return;
    
    // ç­‰å¾…è¿æ¥æ¢å¤
    await provider.whenSynced;
    
    // åº”ç”¨æœ¬åœ°æ›´æ”¹ï¼ˆYjsä¼šè‡ªåŠ¨å¤„ç†å†²çªï¼‰
    localChanges.forEach(change => {
      this.updateMatchData(matchId, change);
    });
  }
}
```

## ğŸ“± è£åˆ¤ç«¯ç§»åŠ¨ç•Œé¢è®¾è®¡

### 1. è§¦æ§ä¼˜å…ˆçš„UIç»„ä»¶

```vue
<!-- components/scoring/TouchScoringPad.vue -->
<template>
  <div class="touch-scoring-pad" :class="{ 'dark-mode': darkMode }">
    <!-- å¤§å±æ¯”åˆ†æ˜¾ç¤º -->
    <div class="score-display">
      <TouchScoreButton 
        :score="leftScore" 
        side="left"
        @increment="incrementLeft"
        @decrement="decrementLeft"
        @long-press="resetLeft"
      />
      
      <div class="match-info">
        <div class="fencer-info left">
          <Avatar :fencer="leftFencer" size="lg" />
          <span class="name">{{ leftFencer.displayName }}</span>
          <span class="country">{{ leftFencer.countryCode }}</span>
        </div>
        
        <div class="timer-section">
          <CountdownTimer 
            :time="timeRemaining" 
            @timeout="handleTimeout"
            @warning="playWarningSound"
          />
          <div class="period-indicator">
            <span v-for="n in 3" :key="n" :class="{ active: currentPeriod >= n }">
              P{{ n }}
            </span>
          </div>
        </div>
        
        <div class="fencer-info right">
          <Avatar :fencer="rightFencer" size="lg" />
          <span class="name">{{ rightFencer.displayName }}</span>
          <span class="country">{{ rightFencer.countryCode }}</span>
        </div>
      </div>
      
      <TouchScoreButton 
        :score="rightScore" 
        side="right"
        @increment="incrementRight"
        @decrement="decrementRight"
        @long-press="resetRight"
      />
    </div>
    
    <!-- å¡ç‰‡æ§åˆ¶åŒº -->
    <div class="card-controls">
      <TouchCardButton 
        type="yellow" 
        @tap="issueCard('YELLOW', 'left')"
        @swipe-left="issueCard('YELLOW', 'right')"
        :disabled="!canIssueCard"
      >
        <IconWarning />
      </TouchCardButton>
      
      <TouchCardButton 
        type="red" 
        @tap="issueCard('RED', 'left')"
        @swipe-left="issueCard('RED', 'right')"
        :disabled="!canIssueCard"
      >
        <IconStop />
      </TouchCardButton>
      
      <TouchCardButton 
        type="black" 
        @tap="issueCard('BLACK', 'left')"
        @swipe-left="issueCard('BLACK', 'right')"
        :disabled="!canIssueCard"
      >
        <IconBan />
      </TouchCardButton>
    </div>
    
    <!-- æ¯”èµ›æ§åˆ¶ -->
    <div class="match-controls">
      <TouchActionButton 
        @tap="togglePause"
        :active="isPaused"
        vibration
      >
        {{ isPaused ? 'ç»§ç»­' : 'æš‚åœ' }}
      </TouchActionButton>
      
      <TouchActionButton 
        @tap="requestVideoReview"
        vibration
      >
        <IconVideo />
        è§†é¢‘å›æ”¾
      </TouchActionButton>
      
      <TouchActionButton 
        @tap="endMatch"
        color="danger"
        :disabled="!canEndMatch"
        vibration
      >
        ç»“æŸæ¯”èµ›
      </TouchActionButton>
    </div>
    
    <!-- æ‰‹åŠ¿æç¤º -->
    <GestureHint 
      v-if="showGestureHint"
      :gestures="gestureInstructions"
    />
  </div>
</template>

<script setup lang="ts">
import { useVibration } from '@/composables/useVibration';
import { useGesture } from '@vueuse/gesture';
import { useAudio } from '@/composables/useAudio';

const { vibrate } = useVibration();
const { playSound } = useAudio();

// æ‰‹åŠ¿æ§åˆ¶
const scorePad = ref<HTMLElement>();

useGesture(
  {
    onPinch: ({ direction, distance }) => {
      // åŒæŒ‡ç¼©æ”¾è°ƒæ•´æ—¶é—´
      if (distance > 50) {
        adjustTime(direction[1] > 0 ? 30 : -30);
      }
    },
    onSwipe: ({ direction, velocity }) => {
      // å¿«é€Ÿæ»‘åŠ¨å‡ºç‰Œ
      if (velocity > 0.5) {
        if (direction[0] === -1) {
          // å‘å·¦æ»‘ï¼Œç»™å³ä¾§é€‰æ‰‹å‡ºç‰Œ
          issueCard('YELLOW', 'right');
        } else if (direction[0] === 1) {
          // å‘å³æ»‘ï¼Œç»™å·¦ä¾§é€‰æ‰‹å‡ºç‰Œ
          issueCard('YELLOW', 'left');
        }
      }
    }
  },
  { domTarget: scorePad, eventOptions: { passive: true } }
);

const incrementLeft = () => {
  leftScore.value++;
  playSound('score');
  vibrate([50]);
  logAction('SCORE_INCREMENT', { side: 'left', newScore: leftScore.value });
};

const issueCard = (type: CardType, side: 'left' | 'right') => {
  playSound('card');
  vibrate([100, 50, 100]);
  
  // è®°å½•å®¡è®¡æ—¥å¿—
  logAction('CARD_ISSUED', {
    type,
    side,
    timestamp: Date.now(),
    matchId: props.matchId
  });
};
</script>

<style scoped>
.touch-scoring-pad {
  --touch-target-size: 60px;
  --primary-color: #409eff;
  --danger-color: #f56c6c;
  --warning-color: #e6a23c;
  
  height: 100vh;
  display: flex;
  flex-direction: column;
  background: #f5f7fa;
  touch-action: manipulation;
}

.score-display {
  display: flex;
  height: 50vh;
}

.touch-score-button {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 4rem;
  font-weight: bold;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

.touch-score-button.left {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
}

.touch-score-button.right {
  background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
  color: white;
}

/* ç¡®ä¿è§¦æ‘¸ç›®æ ‡è¶³å¤Ÿå¤§ */
@media (pointer: coarse) {
  .touch-score-button,
  .touch-card-button,
  .touch-action-button {
    min-height: var(--touch-target-size);
    min-width: var(--touch-target-size);
  }
  
  /* é˜²æ­¢åŒå‡»ç¼©æ”¾ */
  * {
    touch-action: manipulation;
  }
}
</style>
```

### 2. æ‰‹åŠ¿æŒ‡ä»¤ç³»ç»Ÿ

```typescript
// composables/useGestureCommands.ts
export const useGestureCommands = () => {
  const gestures = ref<GestureConfig[]>([
    {
      name: 'swipe_left',
      description: 'å‘å·¦æ»‘åŠ¨ - ç»™å³ä¾§é€‰æ‰‹é»„ç‰Œ',
      handler: () => issueCard('YELLOW', 'right'),
      icon: 'â†'
    },
    {
      name: 'swipe_right',
      description: 'å‘å³æ»‘åŠ¨ - ç»™å·¦ä¾§é€‰æ‰‹é»„ç‰Œ',
      handler: () => issueCard('YELLOW', 'left'),
      icon: 'â†’'
    },
    {
      name: 'swipe_up',
      description: 'å‘ä¸Šæ»‘åŠ¨ - æš‚åœ/ç»§ç»­æ¯”èµ›',
      handler: togglePause,
      icon: 'â†‘'
    },
    {
      name: 'swipe_down',
      description: 'å‘ä¸‹æ»‘åŠ¨ - è¯·æ±‚è§†é¢‘å›æ”¾',
      handler: requestVideoReview,
      icon: 'â†“'
    },
    {
      name: 'double_tap',
      description: 'åŒå‡» - æ’¤é”€ä¸Šä¸€ä¸ªæ“ä½œ',
      handler: undoLastAction,
      icon: 'âŸ²'
    },
    {
      name: 'long_press',
      description: 'é•¿æŒ‰ - é‡ç½®æ¯”åˆ†',
      handler: resetScores,
      icon: 'â±ï¸'
    }
  ]);

  // æ‰‹åŠ¿è®­ç»ƒæ¨¡å¼
  const trainingMode = ref(false);
  
  const enableTraining = () => {
    trainingMode.value = true;
    // æ˜¾ç¤ºæ‰‹åŠ¿æç¤º
    showGestureHints();
    
    // æ’­æ”¾æ•™å­¦éŸ³é¢‘
    playTrainingAudio();
  };
  
  return {
    gestures,
    trainingMode,
    enableTraining
  };
};
```

## ğŸ–¨ï¸ ä¸“ä¸šæ‰“å°ç³»ç»Ÿ

### 1. PDFç”Ÿæˆå¼•æ“

```typescript
// printing/generators/BracketGenerator.ts
export class BracketGenerator {
  private doc: jsPDF;
  private currentY = 0;
  private readonly MARGIN = 20;
  private readonly PAGE_WIDTH = 210; // A4 width in mm
  private readonly PAGE_HEIGHT = 297; // A4 height in mm
  
  constructor(options: BracketOptions = {}) {
    this.doc = new jsPDF({
      orientation: options.orientation || 'portrait',
      unit: 'mm',
      format: 'a4'
    });
    
    // è®¾ç½®ä¸­æ–‡å­—ä½“
    this.setupChineseFont();
  }
  
  private setupChineseFont() {
    // æ·»åŠ ä¸­æ–‡å­—ä½“æ”¯æŒ
    const fontPath = '/fonts/NotoSansSC-Regular.ttf';
    this.doc.addFont(fontPath, 'NotoSansSC', 'normal');
    this.doc.setFont('NotoSansSC');
  }
  
  generateEliminationBracket(matches: MatchNode[], options: BracketLayoutOptions) {
    const { title, tournamentName, eventName, date } = options;
    
    // æ ‡é¢˜é¡µ
    this.addTitlePage(title, tournamentName, eventName, date);
    this.doc.addPage();
    
    // è®¡ç®—å¯¹é˜µè¡¨å¸ƒå±€
    const bracketLayout = this.calculateBracketLayout(matches);
    
    // ç»˜åˆ¶å¯¹é˜µè¡¨
    this.drawBracket(bracketLayout);
    
    // æ·»åŠ é¡µè„š
    this.addFooter();
    
    return this.doc;
  }
  
  private drawBracket(layout: BracketLayout) {
    const cellWidth = 50;
    const cellHeight = 15;
    const verticalSpacing = 10;
    const horizontalSpacing = 20;
    
    layout.rounds.forEach((round, roundIndex) => {
      round.matches.forEach((match, matchIndex) => {
        const x = this.MARGIN + roundIndex * (cellWidth + horizontalSpacing);
        const y = this.MARGIN + matchIndex * (cellHeight + verticalSpacing);
        
        // ç»˜åˆ¶æ¯”èµ›æ¡†
        this.drawMatchBox(x, y, cellWidth, cellHeight, match);
        
        // ç»˜åˆ¶è¿æ¥çº¿
        if (match.nextMatch) {
          const nextX = x + cellWidth + horizontalSpacing;
          const nextY = this.calculateNextMatchY(match, matchIndex, round);
          this.drawConnector(x + cellWidth, y + cellHeight / 2, nextX, nextY);
        }
      });
    });
  }
  
  private drawMatchBox(x: number, y: number, width: number, height: number, match: MatchNode) {
    // ç»˜åˆ¶çŸ©å½¢
    this.doc.rect(x, y, width, height);
    
    // é€‰æ‰‹A
    this.doc.text(match.fencerA.name, x + 2, y + 5);
    this.doc.text(match.scoreA?.toString() || '', x + width - 10, y + 5);
    
    // é€‰æ‰‹B
    this.doc.text(match.fencerB.name, x + 2, y + 12);
    this.doc.text(match.scoreB?.toString() || '', x + width - 10, y + 12);
    
    // æ¯”èµ›ç¼–å·
    this.doc.setFontSize(8);
    this.doc.text(match.matchCode, x + 2, y - 2);
    this.doc.setFontSize(12);
  }
  
  private drawConnector(x1: number, y1: number, x2: number, y2: number) {
    // ç»˜åˆ¶è¿æ¥çº¿ï¼ˆè´å¡å°”æ›²çº¿ï¼‰
    const cp1x = x1 + 10;
    const cp1y = y1;
    const cp2x = x2 - 10;
    const cp2y = y2;
    
    this.doc.setDrawColor(0, 0, 0);
    this.doc.setLineWidth(0.5);
    this.doc.line(x1, y1, cp1x, cp1y);
    this.doc.line(cp2x, cp2y, x2, y2);
    
    // ç»˜åˆ¶æ›²çº¿
    this.doc.curve(cp1x, cp1y, cp2x, cp2y, x1, y1, x2, y2);
  }
  
  // ç”ŸæˆäºŒç»´ç 
  private addQRCode(url: string, x: number, y: number, size: number = 20) {
    const qrCodeData = QRCode.generatePNG(url, {
      errorCorrectionLevel: 'M',
      typeNumber: 4,
      size: size * 4 // æé«˜åˆ†è¾¨ç‡
    });
    
    const qrCodeBase64 = `data:image/png;base64,${btoa(qrCodeData)}`;
    this.doc.addImage(qrCodeBase64, 'PNG', x, y, size, size);
  }
}
```

### 2. æ‰“å°é˜Ÿåˆ—ç®¡ç†å™¨

```typescript
// printing/queue/PrintQueueManager.ts
export class PrintQueueManager {
  private queue: PrintJob[] = [];
  private isProcessing = false;
  private printers = new Map<string, Printer>();
  
  constructor() {
    // æ£€æµ‹å¯ç”¨æ‰“å°æœº
    this.detectPrinters();
    
    // ç›‘å¬æ‰“å°å®Œæˆäº‹ä»¶
    window.addEventListener('afterprint', () => {
      this.onPrintComplete();
    });
  }
  
  async addJob(job: PrintJob) {
    const jobWithId = {
      ...job,
      id: uuidv4(),
      status: 'queued' as const,
      createdAt: Date.now(),
      attempts: 0
    };
    
    this.queue.push(jobWithId);
    
    // å¦‚æœæ˜¯ç´§æ€¥ä»»åŠ¡ï¼ˆå¦‚æ¯”èµ›ç»“æœï¼‰ï¼Œç«‹å³å¤„ç†
    if (job.priority === 'urgent') {
      await this.processQueue();
    } else {
      this.scheduleProcessing();
    }
    
    return jobWithId.id;
  }
  
  private async processQueue() {
    if (this.isProcessing || this.queue.length === 0) return;
    
    this.isProcessing = true;
    
    while (this.queue.length > 0) {
      const job = this.queue[0];
      
      try {
        job.status = 'processing';
        job.startedAt = Date.now();
        
        await this.executePrintJob(job);
        
        // æ‰“å°æˆåŠŸ
        job.status = 'completed';
        job.completedAt = Date.now();
        this.queue.shift();
        
        // è§¦å‘æˆåŠŸäº‹ä»¶
        this.emitPrintEvent('success', job);
        
      } catch (error) {
        job.attempts++;
        job.lastError = error.message;
        
        if (job.attempts >= job.maxRetries) {
          // è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°
          job.status = 'failed';
          this.queue.shift();
          this.emitPrintEvent('failed', job);
        } else {
          // é‡æ–°æ’é˜Ÿç­‰å¾…é‡è¯•
          job.status = 'queued';
          const backoffTime = Math.min(5000 * job.attempts, 60000);
          setTimeout(() => this.processQueue(), backoffTime);
        }
      }
    }
    
    this.isProcessing = false;
  }
  
  private async executePrintJob(job: PrintJob) {
    switch (job.type) {
      case 'pdf':
        await this.printPDF(job);
        break;
      case 'thermal':
        await this.printThermal(job);
        break;
      case 'scorecard':
        await this.printScoreCard(job);
        break;
      default:
        throw new Error(`Unknown print type: ${job.type}`);
    }
  }
  
  private async printPDF(job: PDFPrintJob) {
    // ç”ŸæˆPDF
    const pdf = job.generator.generate();
    
    // å¦‚æœæ˜¯æµè§ˆå™¨æ‰“å°
    if (job.printerType === 'browser') {
      const pdfBlob = pdf.output('blob');
      const url = URL.createObjectURL(pdfBlob);
      
      const printWindow = window.open(url, '_blank');
      if (!printWindow) {
        throw new Error('æ— æ³•æ‰“å¼€æ‰“å°çª—å£ï¼Œè¯·æ£€æŸ¥å¼¹çª—é˜»æ­¢è®¾ç½®');
      }
      
      printWindow.onload = () => {
        printWindow.print();
      };
      
    } else if (job.printerType === 'network') {
      // å‘é€åˆ°ç½‘ç»œæ‰“å°æœº
      await this.sendToNetworkPrinter(job.printerId, pdf);
    }
  }
  
  private async printThermal(job: ThermalPrintJob) {
    // ä½¿ç”¨WebUSBæˆ–WebSocketè¿æ¥çƒ­æ•æ‰“å°æœº
    const printer = this.printers.get(job.printerId);
    if (!printer) throw new Error('æ‰“å°æœºæœªè¿æ¥');
    
    // ESC/POSæŒ‡ä»¤
    const commands = [
      '\x1B\x40', // åˆå§‹åŒ–
      '\x1B\x61\x01', // å±…ä¸­
      `TOURNAMENT: ${job.tournamentName}\n\n`,
      '\x1B\x45\x01', // åŠ ç²—
      `${job.matchCode}\n`,
      '\x1B\x45\x00', // å–æ¶ˆåŠ ç²—
      `Time: ${formatTime(job.startTime)}\n`,
      `Piste: ${job.pisteNumber}\n\n`,
      '\x1D\x21\x01', // åŒå€é«˜åº¦
      `${job.fencerA.name} vs ${job.fencerB.name}\n`,
      '\x1D\x21\x00',
      `Score: ${job.scoreA} - ${job.scoreB}\n\n`,
      '\x1B\x61\x00', // å·¦å¯¹é½
      `Referee: ${job.refereeName}\n`,
      `Printed: ${new Date().toLocaleString()}\n`,
      '\x1B\x69', // åˆ‡çº¸
    ];
    
    await printer.write(commands.join(''));
  }
}
```

## ğŸŒ å¤šçª—å£é€šä¿¡ç³»ç»Ÿ

### 1. Broadcast Channelç®¡ç†å™¨

```typescript
// utils/broadcast/BroadcastManager.ts
export class BroadcastManager {
  private channels = new Map<string, BroadcastChannel>();
  private listeners = new Map<string, Set<(data: any) => void>>();
  
  constructor() {
    this.setupDefaultChannels();
  }
  
  private setupDefaultChannels() {
    const defaultChannels = [
      'display-control',     // æ§åˆ¶å¤§å±æ˜¾ç¤º
      'score-updates',       // æ¯”åˆ†æ›´æ–°
      'tournament-state',    // èµ›äº‹çŠ¶æ€
      'hardware-events',     // ç¡¬ä»¶äº‹ä»¶
      'print-jobs',          // æ‰“å°ä»»åŠ¡
    ];
    
    defaultChannels.forEach(name => {
      this.createChannel(name);
    });
  }
  
  createChannel(name: string): BroadcastChannel {
    const channel = new BroadcastChannel(name);
    this.channels.set(name, channel);
    
    channel.onmessage = (event) => {
      this.handleMessage(name, event.data);
    };
    
    return channel;
  }
  
  sendMessage(channelName: string, message: BroadcastMessage) {
    const channel = this.channels.get(channelName);
    if (!channel) {
      throw new Error(`Channel ${channelName} not found`);
    }
    
    const messageWithMetadata = {
      ...message,
      _metadata: {
        sender: window.name || 'unknown',
        timestamp: Date.now(),
        version: '1.0'
      }
    };
    
    channel.postMessage(messageWithMetadata);
  }
  
  subscribe(channelName: string, callback: (data: any) => void) {
    if (!this.listeners.has(channelName)) {
      this.listeners.set(channelName, new Set());
    }
    this.listeners.get(channelName)!.add(callback);
    
    // è¿”å›å–æ¶ˆè®¢é˜…å‡½æ•°
    return () => {
      this.listeners.get(channelName)?.delete(callback);
    };
  }
  
  private handleMessage(channelName: string, data: any) {
    const listeners = this.listeners.get(channelName);
    if (!listeners) return;
    
    listeners.forEach(callback => {
      try {
        callback(data);
      } catch (error) {
        console.error(`Error in broadcast listener for ${channelName}:`, error);
      }
    });
  }
  
  // å¤§å±æ˜¾ç¤ºæ§åˆ¶
  controlDisplay(command: DisplayCommand) {
    this.sendMessage('display-control', {
      type: 'DISPLAY_COMMAND',
      command,
      target: 'all' // æˆ–æŒ‡å®šçª—å£ID
    });
  }
  
  // æ¯”åˆ†åŒæ­¥åˆ°æ‰€æœ‰æ˜¾ç¤ºç«¯
  syncScoreToDisplays(matchId: string, score: MatchScore) {
    this.sendMessage('score-updates', {
      type: 'SCORE_UPDATE',
      matchId,
      score,
      timestamp: Date.now()
    });
  }
}
```

### 2. å¤§å±æ˜¾ç¤ºæ§åˆ¶å™¨

```typescript
// display/DisplayController.ts
export class DisplayController {
  private broadcast: BroadcastManager;
  private displayWindows = new Map<string, Window>();
  
  constructor() {
    this.broadcast = new BroadcastManager();
    
    // ç›‘å¬æ˜¾ç¤ºæ§åˆ¶å‘½ä»¤
    this.broadcast.subscribe('display-control', (message) => {
      this.handleDisplayCommand(message);
    });
  }
  
  // æ‰“å¼€å¤§å±æ˜¾ç¤ºçª—å£
  openDisplayWindow(type: DisplayType, options: DisplayOptions = {}) {
    const features = [
      'fullscreen=yes',
      'toolbar=no',
      'location=no',
      'directories=no',
      'status=no',
      'menubar=no',
      'scrollbars=no',
      'resizable=no',
    ].join(',');
    
    const url = `/display/${type}?tournament=${options.tournamentId}`;
    const windowName = `display-${type}-${Date.now()}`;
    
    const win = window.open(url, windowName, features);
    if (!win) {
      throw new Error('æ— æ³•æ‰“å¼€æ˜¾ç¤ºçª—å£ï¼Œè¯·æ£€æŸ¥å¼¹çª—é˜»æ­¢è®¾ç½®');
    }
    
    this.displayWindows.set(windowName, win);
    
    // çª—å£å…³é—­æ—¶æ¸…ç†
    const checkClosed = setInterval(() => {
      if (win.closed) {
        this.displayWindows.delete(windowName);
        clearInterval(checkClosed);
      }
    }, 1000);
    
    return windowName;
  }
  
  // æ§åˆ¶æ‰€æœ‰æ˜¾ç¤ºçª—å£
  broadcastToDisplays(command: DisplayCommand) {
    this.displayWindows.forEach((win, name) => {
      try {
        win.postMessage({
          type: 'DISPLAY_COMMAND',
          command,
          source: 'controller'
        }, '*');
      } catch (error) {
        console.error(`æ— æ³•å‘é€æ¶ˆæ¯åˆ°çª—å£ ${name}:`, error);
      }
    });
  }
  
  // æ˜¾ç¤ºç‰¹å®šæ¯”èµ›
  showMatchOnDisplays(matchId: string, displayType: 'scoreboard' | 'bracket' | 'stats') {
    this.broadcastToDisplays({
      action: 'SHOW_MATCH',
      matchId,
      displayType
    });
  }
  
  // æ˜¾ç¤ºå¹¿å‘Šæˆ–é€šçŸ¥
  showAdvertisement(content: Advertisement) {
    this.broadcastToDisplays({
      action: 'SHOW_ADVERTISEMENT',
      content,
      duration: content.duration || 10000
    });
  }
  
  // ç´§æ€¥å¹¿æ’­
  emergencyBroadcast(message: string) {
    this.broadcastToDisplays({
      action: 'EMERGENCY_BROADCAST',
      message,
      priority: 'high'
    });
  }
}
```

## ğŸ¨ UI/UXè®¾è®¡ç³»ç»Ÿ

### 1. ä¸»é¢˜ä¸æ— éšœç¢è®¾è®¡

```scss
// styles/theme/_variables.scss
:root {
  // å‡»å‰‘ä¸»é¢˜è‰²
  --fencer-primary: #0066cc;      // å›½é™…å‰‘è”è“
  --fencer-secondary: #cc0000;    // çº¢ç‰Œçº¢
  --fencer-warning: #ffcc00;      // é»„ç‰Œé»„
  --fencer-success: #00aa00;      // æˆåŠŸç»¿
  --fencer-danger: #cc0000;       // å±é™©çº¢
  
  // å¯¹æ¯”åº¦ç¡®ä¿æ— éšœç¢
  --text-primary: #000000;
  --text-secondary: #666666;
  --text-on-primary: #ffffff;
  --text-on-danger: #ffffff;
  
  // è§¦æ§ç›®æ ‡å°ºå¯¸
  --touch-target-min: 44px;
  --touch-target-ideal: 48px;
  
  // åŠ¨ç”»
  --transition-fast: 150ms;
  --transition-normal: 300ms;
  --transition-slow: 500ms;
  
  // å­—ä½“
  --font-family-base: 'Inter', 'Noto Sans SC', sans-serif;
  --font-family-mono: 'Roboto Mono', monospace;
}

// é«˜å¯¹æ¯”åº¦æ¨¡å¼
.high-contrast {
  --text-primary: #000000;
  --text-secondary: #333333;
  --fencer-primary: #0000aa;
  --fencer-secondary: #aa0000;
  --background-primary: #ffffff;
  --background-secondary: #f0f0f0;
  
  * {
    border-width: 2px !important;
  }
}

// æš—é»‘æ¨¡å¼ï¼ˆé€‚åˆæ¯”èµ›åœºé¦†ï¼‰
.dark-mode {
  --background-primary: #121212;
  --background-secondary: #1e1e1e;
  --text-primary: #ffffff;
  --text-secondary: #b0b0b0;
  --fencer-primary: #4dabf7;
  
  // é™ä½äº®åº¦ï¼Œå‡å°‘å¯¹è¿åŠ¨å‘˜å½±å“
  filter: brightness(0.9);
}
```

### 2. è£åˆ¤ç«¯ä¸“ç”¨æ ·å¼

```scss
// styles/referee.scss
.referee-interface {
  // é˜²è¯¯è§¦
  touch-action: manipulation;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  
  // å¤§è§¦æ§åŒºåŸŸ
  button, .touch-target {
    min-height: var(--touch-target-ideal);
    min-width: var(--touch-target-ideal);
    padding: 12px 24px;
    border-radius: 12px;
    font-size: 1.5rem;
    font-weight: 600;
    
    // é˜²æ­¢ç‚¹å‡»é«˜äº®
    -webkit-tap-highlight-color: transparent;
    
    // æŒ‰å‹æ•ˆæœ
    &:active {
      transform: scale(0.95);
      transition: transform var(--transition-fast);
    }
    
    // ç¦ç”¨çŠ¶æ€
    &:disabled {
      opacity: 0.5;
      filter: grayscale(0.5);
      pointer-events: none;
    }
  }
  
  // ç´§æ€¥æŒ‰é’®
  .emergency-button {
    background: linear-gradient(135deg, var(--fencer-danger), #ff3333);
    color: white;
    font-size: 2rem;
    padding: 24px;
    border: 4px solid white;
    box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
    
    // é—ªçƒåŠ¨ç”»
    &.active {
      animation: pulse 1s infinite;
    }
  }
  
  // å¾—åˆ†æŒ‰é’®
  .score-button {
    font-size: 4rem;
    font-weight: 900;
    border: 6px solid currentColor;
    
    &.left { color: var(--fencer-primary); }
    &.right { color: var(--fencer-secondary); }
    
    // å¾—åˆ†åŠ¨ç”»
    &.scored {
      animation: scorePulse 0.5s;
    }
  }
  
  // æŒ¯åŠ¨åé¦ˆç±»
  .vibrate-on-tap {
    @media (hover: none) and (pointer: coarse) {
      &:active {
        // è§¦å‘è®¾å¤‡æŒ¯åŠ¨
      }
    }
  }
}

// åŠ¨ç”»å®šä¹‰
@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

@keyframes scorePulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}

// æ‰‹åŠ¿æç¤º
.gesture-hint {
  position: fixed;
  bottom: 20px;
  right: 20px;
  background: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 16px;
  border-radius: 16px;
  backdrop-filter: blur(10px);
  z-index: 1000;
  
  .gesture-icon {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    margin-right: 12px;
  }
}
```

## ğŸ” å®‰å…¨ä¸å®¡è®¡

### 1. å‰ç«¯æ“ä½œå®¡è®¡

```typescript
// stores/audit.store.ts
export const useAuditStore = defineStore('audit', () => {
  const logs = ref<AuditLog[]>([]);
  const MAX_LOG_SIZE = 10000;
  
  // è®°å½•æ“ä½œ
  const logAction = (action: AuditAction, details: Record<string, any> = {}) => {
    const user = useAuthStore().currentUser;
    const log: AuditLog = {
      id: uuidv4(),
      timestamp: Date.now(),
      user: user ? {
        id: user.id,
        name: user.displayName,
        role: user.role
      } : undefined,
      action,
      details,
      context: {
        url: window.location.href,
        userAgent: navigator.userAgent,
        screen: `${window.screen.width}x${window.screen.height}`,
        online: navigator.onLine
      }
    };
    
    // æ·»åŠ åˆ°å†…å­˜
    logs.value.unshift(log);
    
    // é™åˆ¶æ—¥å¿—å¤§å°
    if (logs.value.length > MAX_LOG_SIZE) {
      logs.value = logs.value.slice(0, MAX_LOG_SIZE);
    }
    
    // æŒä¹…åŒ–åˆ°IndexedDB
    persistLog(log);
    
    // å‘é€åˆ°æœåŠ¡å™¨ï¼ˆå¦‚æœåœ¨çº¿ï¼‰
    if (navigator.onLine) {
      sendLogToServer(log);
    }
    
    return log;
  };
  
  // å…³é”®æ“ä½œè®°å½•
  const criticalActions = [
    'SCORE_UPDATE',
    'CARD_ISSUED',
    'MATCH_START',
    'MATCH_END',
    'BRACKET_MODIFICATION',
    'REFEREE_ASSIGNMENT',
    'HARDWARE_CONNECTION'
  ];
  
  // åˆ›å»ºå®¡è®¡ä¸­é—´ä»¶
  const createAuditMiddleware = (actionType: string) => {
    return (payload: any) => {
      // è®°å½•å‰å¿«ç…§
      const beforeSnapshot = captureSnapshot();
      
      // æ‰§è¡ŒåŸæ“ä½œ
      const result = originalFunction(payload);
      
      // è®°å½•åå¿«ç…§
      const afterSnapshot = captureSnapshot();
      
      // è®°å½•å®¡è®¡æ—¥å¿—
      logAction(actionType, {
        payload,
        before: beforeSnapshot,
        after: afterSnapshot,
        result
      });
      
      return result;
    };
  };
  
  // å¯¼å‡ºå®¡è®¡æ—¥å¿—
  const exportLogs = (format: 'json' | 'csv' | 'pdf') => {
    const data = logs.value;
    
    switch (format) {
      case 'json':
        return JSON.stringify(data, null, 2);
      case 'csv':
        return convertToCSV(data);
      case 'pdf':
        return generateAuditPDF(data);
    }
  };
  
  return {
    logs,
    logAction,
    createAuditMiddleware,
    exportLogs
  };
});
```

### 2. æ’¤é”€/é‡åšç³»ç»Ÿ

```typescript
// utils/undo/UndoManager.ts
export class UndoManager {
  private stack: UndoAction[] = [];
  private redoStack: UndoAction[] = [];
  private maxStackSize = 100;
  
  constructor(private store: any) {
    // ç›‘å¬çŠ¶æ€å˜åŒ–
    this.setupStoreListener();
  }
  
  private setupStoreListener() {
    // ä½¿ç”¨Proxyç›‘å¬çŠ¶æ€å˜åŒ–
    this.store.$subscribe((mutation, state) => {
      // å¿½ç•¥æŸäº›mutationï¼ˆå¦‚UIçŠ¶æ€ï¼‰
      if (this.shouldIgnoreMutation(mutation)) return;
      
      this.recordChange(mutation, state);
    });
  }
  
  recordChange(mutation: any, newState: any) {
    const action: UndoAction = {
      id: uuidv4(),
      type: mutation.type,
      payload: mutation.payload,
      timestamp: Date.now(),
      before: this.captureSnapshot(),
      after: newState
    };
    
    this.stack.push(action);
    this.redoStack = []; // æ¸…ç©ºé‡åšæ ˆ
    
    // é™åˆ¶æ ˆå¤§å°
    if (this.stack.length > this.maxStackSize) {
      this.stack.shift();
    }
  }
  
  undo() {
    if (this.stack.length === 0) return false;
    
    const action = this.stack.pop()!;
    this.redoStack.push(action);
    
    // æ¢å¤åˆ°ä¹‹å‰çš„çŠ¶æ€
    this.applySnapshot(action.before);
    
    // è®°å½•æ’¤é”€æ“ä½œ
    useAuditStore().logAction('UNDO_ACTION', {
      actionId: action.id,
      actionType: action.type
    });
    
    return true;
  }
  
  redo() {
    if (this.redoStack.length === 0) return false;
    
    const action = this.redoStack.pop()!;
    this.stack.push(action);
    
    // åº”ç”¨é‡åšçš„çŠ¶æ€
    this.applySnapshot(action.after);
    
    // è®°å½•é‡åšæ“ä½œ
    useAuditStore().logAction('REDO_ACTION', {
      actionId: action.id,
      actionType: action.type
    });
    
    return true;
  }
  
  // å¿«ç…§å·¥å…·
  private captureSnapshot(): StateSnapshot {
    return {
      timestamp: Date.now(),
      data: deepClone(this.store.$state),
      version: '1.0'
    };
  }
  
  private applySnapshot(snapshot: StateSnapshot) {
    Object.keys(snapshot.data).forEach(key => {
      this.store.$state[key] = snapshot.data[key];
    });
  }
}
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. è™šæ‹ŸåŒ–ä¸æ‡’åŠ è½½

```vue
<!-- å¤§å‹å¯¹é˜µè¡¨çš„è™šæ‹Ÿæ»šåŠ¨ -->
<template>
  <VirtualScroll
    :items="matches"
    :item-height="60"
    :buffer="10"
    class="bracket-container"
  >
    <template #default="{ item, index }">
      <MatchCard
        :match="item"
        :style="{ transform: `translateY(${index * 60}px)` }"
        class="match-card"
      />
    </template>
  </VirtualScroll>
</template>

<!-- å›¾ç‰‡æ‡’åŠ è½½ -->
<template>
  <img
    v-for="fencer in fencers"
    :key="fencer.id"
    :data-src="fencer.photoUrl"
    class="lazy-load"
    alt="fencer photo"
  />
</template>

<script setup>
import { useIntersectionObserver } from '@vueuse/core';

const images = ref<HTMLImageElement[]>([]);

onMounted(() => {
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target as HTMLImageElement;
        img.src = img.dataset.src || '';
        observer.unobserve(img);
      }
    });
  }, { rootMargin: '50px' });

  images.value.forEach(img => observer.observe(img));
});
</script>
```

### 2. Web Workers ä¼˜åŒ–

```typescript
// workers/DataSyncWorker.ts
// åœ¨Web Workerä¸­å¤„ç†æ•°æ®åŒæ­¥
self.addEventListener('message', async (event) => {
  const { type, payload } = event.data;
  
  switch (type) {
    case 'SYNC_OFFLINE_DATA':
      await syncOfflineData(payload);
      break;
      
    case 'GENERATE_PDF':
      const pdf = await generatePDF(payload);
      self.postMessage({ type: 'PDF_GENERATED', pdf });
      break;
      
    case 'CALCULATE_RANKINGS':
      const rankings = calculateRankings(payload);
      self.postMessage({ type: 'RANKINGS_CALCULATED', rankings });
      break;
  }
});

async function syncOfflineData(operations: OfflineOperation[]) {
  // åœ¨Workerä¸­æ‰§è¡Œè€—æ—¶çš„åŒæ­¥æ“ä½œ
  const results = await Promise.allSettled(
    operations.map(async (op) => {
      try {
        await apiClient.post(`/${op.endpoint}`, op.data);
        return { id: op.id, status: 'success' };
      } catch (error) {
        return { id: op.id, status: 'error', error: error.message };
      }
    })
  );
  
  return results;
}
```

## ğŸš€ éƒ¨ç½²ä¸ç›‘æ§

### 1. Dockerå¤šå®¹å™¨éƒ¨ç½²

```dockerfile
# admin-app/Dockerfile
FROM node:18-alpine as builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.admin.conf /etc/nginx/nginx.conf
EXPOSE 80

# display-app/Dockerfile
FROM node:18-alpine as builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.display.conf /etc/nginx/nginx.conf
EXPOSE 80

# docker-compose.yml
version: '3.8'
services:
  admin-app:
    build: ./packages/admin-app
    ports:
      - "3000:80"
    environment:
      - VITE_API_URL=https://api.pistemaster.com
      - VITE_WS_URL=wss://ws.pistemaster.com
      - VITE_SENTRY_DSN=${SENTRY_DSN}
    networks:
      - pistemaster
  
  display-app:
    build: ./packages/display-app
    ports:
      - "3001:80"
    environment:
      - VITE_API_URL=https://api.pistemaster.com
      - VITE_WS_URL=wss://ws.pistemaster.com
    networks:
      - pistemaster
  
  referee-app:
    build: ./packages/referee-app
    ports:
      - "3002:80"
    environment:
      - VITE_API_URL=https://api.pistemaster.com
      - VITE_WS_URL=wss://ws.pistemaster.com
    networks:
      - pistemaster

networks:
  pistemaster:
    driver: bridge
```

### 2. æ€§èƒ½ç›‘æ§é…ç½®

```typescript
// utils/monitoring/performance.ts
export class PerformanceMonitor {
  private metrics = new Map<string, PerformanceMetric[]>();
  
  constructor() {
    // ç›‘å¬Web Vitals
    this.setupWebVitals();
    
    // ç›‘å¬è‡ªå®šä¹‰æ€§èƒ½æŒ‡æ ‡
    this.setupCustomMetrics();
  }
  
  private setupWebVitals() {
    import('web-vitals').then(({ onCLS, onFID, onLCP }) => {
      onCLS(this.reportMetric);
      onFID(this.reportMetric);
      onLCP(this.reportMetric);
    });
  }
  
  private setupCustomMetrics() {
    // å…³é”®ä¸šåŠ¡æ“ä½œè€—æ—¶
    performance.mark('app-start');
    
    // è·¯ç”±åˆ‡æ¢è€—æ—¶
    const router = useRouter();
    router.beforeEach((to, from) => {
      performance.mark(`route-start-${to.name}`);
    });
    
    router.afterEach((to) => {
      performance.mark(`route-end-${to.name}`);
      performance.measure(
        `route-${to.name}`,
        `route-start-${to.name}`,
        `route-end-${to.name}`
      );
      
      const measure = performance.getEntriesByName(`route-${to.name}`)[0];
      this.reportMetric('ROUTE_LOAD', measure.duration);
    });
  }
  
  // è®°å½•ç¡¬ä»¶å“åº”æ—¶é—´
  measureHardwareResponse(eventType: string, startTime: number) {
    const duration = Date.now() - startTime;
    this.reportMetric(`HARDWARE_${eventType}`, duration);
    
    // å¦‚æœå“åº”æ—¶é—´è¿‡é•¿ï¼Œå‘å‡ºè­¦å‘Š
    if (duration > 1000) {
      console.warn(`ç¡¬ä»¶å“åº”å»¶è¿Ÿ: ${eventType} è€—æ—¶ ${duration}ms`);
    }
  }
  
  // æŠ¥å‘Šåˆ°ç›‘æ§ç³»ç»Ÿ
  private reportMetric(name: string, value: number) {
    const metric: PerformanceMetric = {
      name,
      value,
      timestamp: Date.now(),
      context: {
        userAgent: navigator.userAgent,
        online: navigator.onLine,
        memory: (performance as any).memory
      }
    };
    
    // å­˜å‚¨åˆ°æœ¬åœ°
    this.storeMetric(metric);
    
    // å‘é€åˆ°ç›‘æ§æœåŠ¡
    if (navigator.onLine) {
      this.sendToMonitoringService(metric);
    }
  }
}
```

## ğŸ“‹ å¼€å‘ä¸æµ‹è¯•ç­–ç•¥

### 1. ç¡¬ä»¶æ¨¡æ‹Ÿå™¨ï¼ˆå¼€å‘ç¯å¢ƒï¼‰

```typescript
// dev/hardware-simulator.ts
export class HardwareSimulator {
  private interval: number | null = null;
  
  // æ¨¡æ‹ŸFaveroè£åˆ¤å™¨
  simulateFavero(pisteNumber: number, callback: (data: string) => void) {
    this.interval = setInterval(() => {
      // æ¨¡æ‹Ÿå¾—åˆ†
      if (Math.random() > 0.7) {
        const side = Math.random() > 0.5 ? 'left' : 'right';
        const score = Math.floor(Math.random() * 5);
        
        const frame = this.generateFaveroFrame({
          piste: pisteNumber,
          side,
          score,
          time: 180 - Math.floor(Math.random() * 180)
        });
        
        callback(frame);
      }
    }, 1000);
  }
  
  private generateFaveroFrame(data: any): string {
    // ç”Ÿæˆç¬¦åˆFaveroåè®®çš„å¸§æ•°æ®
    const frameData = [
      0x02, // STX
      data.piste,
      data.side === 'left' ? 0x41 : 0x42,
      data.score,
      ...this.encodeTime(data.time),
      0x03 // ETX
    ];
    
    const checksum = this.calculateChecksum(frameData.slice(1, -1));
    frameData.push(checksum);
    
    return String.fromCharCode(...frameData);
  }
  
  stop() {
    if (this.interval) {
      clearInterval(this.interval);
      this.interval = null;
    }
  }
}
```

### 2. E2Eæµ‹è¯•ç”¨ä¾‹

```typescript
// tests/e2e/tournament-flow.spec.ts
describe('Complete Tournament Flow', () => {
  it('should create and run a full tournament', async ({ page }) => {
    // 1. åˆ›å»ºèµ›äº‹
    await page.goto('/tournaments/new');
    await page.fill('[data-test="tournament-name"]', 'Test Championship');
    await page.click('[data-test="create-tournament"]');
    
    // 2. æ·»åŠ é¡¹ç›®
    await page.click('[data-test="add-event"]');
    await page.selectOption('[data-test="event-type"]', 'MEN_INDIVIDUAL_FOIL');
    await page.click('[data-test="save-event"]');
    
    // 3. å¯¼å…¥è¿åŠ¨å‘˜
    await page.click('[data-test="import-fencers"]');
    const fileInput = page.locator('[data-test="file-input"]');
    await fileInput.setInputFiles('./fixtures/fencers.csv');
    await page.click('[data-test="confirm-import"]');
    
    // 4. ç”Ÿæˆå°ç»„
    await page.click('[data-test="generate-pools"]');
    await page.selectOption('[data-test="pool-size"]', '7');
    await page.click('[data-test="confirm-generation"]');
    
    // 5. æ¨¡æ‹Ÿæ¯”èµ›
    await page.click('[data-test="start-pool-round"]');
    
    // ä½¿ç”¨ç¡¬ä»¶æ¨¡æ‹Ÿå™¨
    await page.evaluate(() => {
      window.hardwareSimulator = new HardwareSimulator();
      window.hardwareSimulator.simulateFavero(1, (data) => {
        window.dispatchEvent(new CustomEvent('hardware:data', { detail: data }));
      });
    });
    
    // éªŒè¯æ¯”åˆ†æ›´æ–°
    await expect(page.locator('[data-test="score-left"]')).toHaveText('5');
    await expect(page.locator('[data-test="score-right"]')).toHaveText('3');
    
    // 6. ç”Ÿæˆæ·˜æ±°èµ›
    await page.click('[data-test="generate-bracket"]');
    await expect(page.locator('[data-test="bracket-match"]')).toHaveCount(16);
    
    // 7. å¯¼å‡ºç»“æœ
    await page.click('[data-test="export-results"]');
    await expect(page.locator('[data-test="download-link"]')).toBeVisible();
  });
});
```

## ğŸ“ˆ è¿ç§»ä¸å‡çº§ç­–ç•¥

### 1. æ¸è¿›å¼è¿ç§»è·¯å¾„

```typescript
// utils/migration/MigrationManager.ts
export class MigrationManager {
  private migrations = new Map<string, Migration>();
  
  constructor() {
    // æ³¨å†Œæ‰€æœ‰è¿ç§»
    this.registerMigrations();
  }
  
  private registerMigrations() {
    // v1.0 -> v1.1: å¢åŠ ç¡¬ä»¶æ”¯æŒ
    this.migrations.set('1.1', {
      version: '1.1',
      description: 'æ·»åŠ ç¡¬ä»¶è®¾å¤‡æ”¯æŒ',
      up: async (data: any) => {
        // è¿ç§»é€»è¾‘
        if (!data.settings) data.settings = {};
        data.settings.hardware = {
          enabled: false,
          connectedDevices: []
        };
        return data;
      },
      down: async (data: any) => {
        // å›æ»šé€»è¾‘
        delete data.settings.hardware;
        return data;
      }
    });
    
    // v1.1 -> v1.2: æ·»åŠ ç¦»çº¿æ”¯æŒ
    this.migrations.set('1.2', {
      version: '1.2',
      description: 'æ·»åŠ ç¦»çº¿æ“ä½œæ”¯æŒ',
      up: async (data: any) => {
        if (!data.offline) data.offline = { queue: [], lastSync: null };
        return data;
      }
    });
  }
  
  async migrate(currentVersion: string, targetVersion: string, data: any) {
    const versions = this.getMigrationPath(currentVersion, targetVersion);
    
    for (const version of versions) {
      const migration = this.migrations.get(version);
      if (!migration) continue;
      
      try {
        console.log(`æ‰§è¡Œè¿ç§»: ${migration.version} - ${migration.description}`);
        data = await migration.up(data);
        
        // è®°å½•è¿ç§»å†å²
        await this.recordMigration(version, 'success');
      } catch (error) {
        console.error(`è¿ç§»å¤±è´¥: ${version}`, error);
        await this.recordMigration(version, 'failed', error);
        throw error;
      }
    }
    
    return data;
  }
}
```

## ğŸ¯ æ€»ç»“

è¿™ä¸ªå¢å¼ºç‰ˆçš„å‰ç«¯æ¶æ„è®¾è®¡é’ˆå¯¹å‡»å‰‘ç¼–æ’è½¯ä»¶çš„ç‰¹æ®Šéœ€æ±‚ï¼Œé‡ç‚¹è§£å†³äº†ä»¥ä¸‹æ ¸å¿ƒé—®é¢˜ï¼š

1. **å¼±ç½‘ç¯å¢ƒ**ï¼šé€šè¿‡PWAã€IndexedDBã€ç¦»çº¿é˜Ÿåˆ—ã€CRDTååŒç¡®ä¿åœ¨ç°åœºç½‘ç»œä¸ç¨³å®šæ—¶ä»èƒ½æ­£å¸¸å·¥ä½œ
2. **ç¡¬ä»¶é›†æˆ**ï¼šå®Œæ•´æ”¯æŒWeb Serial APIã€è“ç‰™è¿æ¥ï¼Œå¯ç›´æ¥å¯¹æ¥ç”µåŠ¨è£åˆ¤å™¨
3. **è£åˆ¤ä½“éªŒ**ï¼šä¸“ä¸ºè§¦æ§ä¼˜åŒ–çš„ç•Œé¢ï¼Œæ”¯æŒæ‰‹åŠ¿æ“ä½œã€æŒ¯åŠ¨åé¦ˆã€å¤§æŒ‰é’®è®¾è®¡
4. **ä¸“ä¸šæ‰“å°**ï¼šå®¢æˆ·ç«¯PDFç”Ÿæˆï¼Œæ”¯æŒçƒ­æ•æ‰“å°æœºï¼Œç¡®ä¿æ‰“å°è´¨é‡
5. **å¤šå±åä½œ**ï¼šBroadcast Channel APIå®ç°å¤šçª—å£åŒæ­¥ï¼Œæ”¯æŒå¤§å±æ˜¾ç¤º
6. **å®¡è®¡è¿½è¸ª**ï¼šå®Œæ•´çš„å‰ç«¯æ“ä½œæ—¥å¿—ï¼Œæ”¯æŒæ’¤é”€/é‡åšï¼Œç¡®ä¿æ•°æ®å¯è¿½æº¯
7. **æ€§èƒ½ä¼˜åŒ–**ï¼šè™šæ‹Ÿæ»šåŠ¨ã€Web Workersã€æ‡’åŠ è½½ç­‰æŠ€æœ¯ç¡®ä¿æµç•…ä½“éªŒ
8. **å›½é™…åŒ–**ï¼šå®Œæ•´æ”¯æŒå¤šè¯­è¨€ï¼Œç‰¹åˆ«æ˜¯å‡»å‰‘æ³•è¯­æœ¯è¯­

è¿™ä¸ªæ¶æ„è®¾è®¡æ—¢è€ƒè™‘äº†æŠ€æœ¯å…ˆè¿›æ€§ï¼Œä¹Ÿå……åˆ†å°Šé‡äº†å‡»å‰‘æ¯”èµ›çš„ä¼ ç»Ÿå’Œå®é™…å·¥ä½œæµç¨‹ï¼Œèƒ½å¤Ÿåœ¨ä¿æŒä¸“ä¸šæ€§çš„åŒæ—¶æä¾›ç°ä»£åŒ–çš„ç”¨æˆ·ä½“éªŒã€‚