# PisteMasterå‰ç«¯æ¶æ„è®¾è®¡æ–‡æ¡£

## ğŸ¯ é¡¹ç›®æ¦‚è¿°

PisteMasteræ˜¯ä¸€æ¬¾é¢å‘å‡»å‰‘æ¯”èµ›ç¼–æ’çš„ä¸“ä¸šè½¯ä»¶ï¼Œæ¶µç›–èµ›äº‹ç®¡ç†ã€å®æ—¶è®¡åˆ†ã€è£åˆ¤è°ƒåº¦ç­‰åŠŸèƒ½ã€‚æœ¬å‰ç«¯æ¶æ„é’ˆå¯¹**ä½“è‚²èµ›äº‹ç°åœºç¯å¢ƒ**çš„ç‰¹æ®Šéœ€æ±‚è¿›è¡Œäº†æ·±åº¦ä¼˜åŒ–ï¼Œç‰¹åˆ«æ”¯æŒç¦»çº¿/åœ¨çº¿æ··åˆæ¨¡å¼ä¸‹çš„æ•°æ®åŒæ­¥ä¸ååŒç¼–è¾‘ã€‚

## ğŸ“¦ æŠ€æœ¯æ ˆé€‰å‹

### æ ¸å¿ƒæ¡†æ¶

- **Vue 3.4+** + **TypeScript 5.0+** + **Composition API**
- **Vite 5.0+** - æ„å»ºå·¥å…·ï¼Œæ”¯æŒMPAå¤šå…¥å£
- **Pinia 2.1+** - çŠ¶æ€ç®¡ç†ï¼Œæ”¯æŒæ’ä»¶æ‰©å±•
- **Vue Router 4.2+** - è·¯ç”±ç®¡ç†

### UIç»„ä»¶

- **Element Plus 2.3+** - ç®¡ç†ç«¯UIåº“
- **è‡ªå®šä¹‰è£åˆ¤ç«¯UI** - æ‰‹å†™å¤§è§¦æ§ç»„ä»¶

### æ•°æ®ä¸çŠ¶æ€

- **IndexedDB** + **idb 8.0+** - å®¢æˆ·ç«¯æ•°æ®åº“
- **Yjs 13.6+** - ååŒç¼–è¾‘æ¡†æ¶ï¼ˆåœ¨çº¿æ¨¡å¼ï¼‰
- **y-websocket 1.6+** - WebSocketååŒè¿æ¥å™¨

### å¯è§†åŒ–ä¸è¡¨æ ¼

- **ECharts 5.4+** + **Vue-ECharts 6.6+** - æ•°æ®å¯è§†åŒ–
- **ag-Grid Community 31.1+** - ä¸“ä¸šçº§æ•°æ®è¡¨æ ¼
- **d3.js 7.8+** - é«˜çº§è‡ªå®šä¹‰å¯è§†åŒ–

### ç¦»çº¿ä¸PWA

- **vite-plugin-pwa 0.19+** - PWAæ”¯æŒ
- **Workbox 7.0+** - Service Workerç®¡ç†
- **localforage 1.10+** - ç®€åŒ–IndexedDBæ“ä½œ

### æ‰“å°ä¸å¯¼å‡º

- **jspdf 2.5+** + **jspdf-autotable 3.5+** - PDFç”Ÿæˆ
- **html2canvas 1.4+** - DOMè½¬å›¾ç‰‡
- **print-js 1.6+** - ç®€åŒ–æ‰“å°

### ååŒç¼–è¾‘

- **Yjs 13.6+** - CRDTååŒæ¡†æ¶
- **y-indexeddb 9.0+** - IndexedDBæŒä¹…åŒ–
- **y-websocket 1.6+** - WebSocketæä¾›è€…

### å›½é™…åŒ–

- **vue-i18n 9.4+** - å¤šè¯­è¨€æ”¯æŒ
- **cldr-core 43.0+** - å›½é™…åŒ–æ•°æ®

### å¼€å‘å·¥å…·

- **Vitest 1.0+** - å•å…ƒæµ‹è¯•
- **Playwright 1.40+** - E2Eæµ‹è¯•
- **ESLint 8.56+** + **Prettier 3.1+** - ä»£ç è§„èŒƒ
- **Sentry 7.81+** - é”™è¯¯ç›‘æ§

## ğŸ—ï¸ é¡¹ç›®æ¶æ„è®¾è®¡

### å¤šå…¥å£æ„å»ºæ¶æ„

```
pistemaster-frontend/
â”œâ”€â”€ packages/                    # Monorepoç»“æ„
â”‚   â”œâ”€â”€ admin-app/              # ç®¡ç†ç«¯åº”ç”¨
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â””â”€â”€ package.json
â”‚   â””â”€â”€ ui-kit/                 # å…±äº«UIç»„ä»¶åº“
â”‚       â”œâ”€â”€ components/
â”‚       â””â”€â”€ package.json
â”œâ”€â”€ shared/                     # å…±äº«ä»£ç 
â”‚   â”œâ”€â”€ types/                  # TypeScriptç±»å‹å®šä¹‰
â”‚   â”œâ”€â”€ utils/                  # é€šç”¨å·¥å…·å‡½æ•°
â”‚   â””â”€â”€ constants/              # å¸¸é‡å®šä¹‰
â””â”€â”€ package.json
```

### ç®¡ç†ç«¯æ ¸å¿ƒæ¶æ„ (admin-app)

```
admin-app/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ api/                    # APIå±‚
â”‚   â”‚   â”œâ”€â”€ http/              # HTTPå®¢æˆ·ç«¯
â”‚   â”‚   â”œâ”€â”€ websocket/         # WebSocketæœåŠ¡
â”‚   â”‚   â”œâ”€â”€ sync/              # æ•°æ®åŒæ­¥æœåŠ¡
â”‚   â”‚   â””â”€â”€ services/          # APIæœåŠ¡
â”‚   â”œâ”€â”€ assets/                # é™æ€èµ„æº
â”‚   â”œâ”€â”€ components/            # ä¸šåŠ¡ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ tournament/        # èµ›äº‹ç®¡ç†ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ bracket/           # å¯¹é˜µè¡¨ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ scoring/           # è®¡åˆ†ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ conflict/          # å†²çªè§£å†³ç»„ä»¶
â”‚   â”‚   â””â”€â”€ printing/          # æ‰“å°ç»„ä»¶
â”‚   â”œâ”€â”€ composables/           # Compositionå‡½æ•°
â”‚   â”‚   â”œâ”€â”€ useSync.ts         # åŒæ­¥é€»è¾‘
â”‚   â”‚   â”œâ”€â”€ useConflict.ts     # å†²çªå¤„ç†
â”‚   â”‚   â””â”€â”€ useOffline.ts      # ç¦»çº¿å¤„ç†
â”‚   â”œâ”€â”€ layouts/               # å¸ƒå±€ç»„ä»¶
â”‚   â”œâ”€â”€ locales/               # å›½é™…åŒ–
â”‚   â”‚   â”œâ”€â”€ fr.ts              # æ³•è¯­ï¼ˆå‡»å‰‘å®˜æ–¹è¯­è¨€ï¼‰
â”‚   â”‚   â”œâ”€â”€ en.ts
â”‚   â”‚   â”œâ”€â”€ zh.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ printing/              # æ‰“å°å¼•æ“
â”‚   â”‚   â”œâ”€â”€ generators/        # ç”Ÿæˆå™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ BracketGenerator.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ ScoreSheetGenerator.ts
â”‚   â”‚   â”‚   â””â”€â”€ CertificateGenerator.ts
â”‚   â”‚   â”œâ”€â”€ templates/         # æ¨¡æ¿
â”‚   â”‚   â””â”€â”€ queue/             # æ‰“å°é˜Ÿåˆ—
â”‚   â”œâ”€â”€ router/                # è·¯ç”±
â”‚   â”œâ”€â”€ stores/                # PiniaçŠ¶æ€
â”‚   â”‚   â”œâ”€â”€ tournament.store.ts
â”‚   â”‚   â”œâ”€â”€ sync.store.ts      # åŒæ­¥çŠ¶æ€
â”‚   â”‚   â””â”€â”€ audit.store.ts     # å®¡è®¡æ—¥å¿—
â”‚   â”œâ”€â”€ types/                 # ç±»å‹å®šä¹‰
â”‚   â”œâ”€â”€ utils/                 # å·¥å…·å‡½æ•°
â”‚   â”‚   â”œâ”€â”€ calculations/      # è®¡ç®—å·¥å…·
â”‚   â”‚   â”œâ”€â”€ formatters/        # æ ¼å¼åŒ–
â”‚   â”‚   â”œâ”€â”€ validators/        # éªŒè¯
â”‚   â”‚   â”œâ”€â”€ sync/              # åŒæ­¥å·¥å…·
â”‚   â”‚   â”œâ”€â”€ conflict/          # å†²çªè§£å†³å·¥å…·
â”‚   â”‚   â””â”€â”€ helpers/           # åŠ©æ‰‹å‡½æ•°
â”‚   â”œâ”€â”€ views/                 # é¡µé¢è§†å›¾
â”‚   â”œâ”€â”€ workers/               # Web Workers
â”‚   â”‚   â”œâ”€â”€ DataSyncWorker.ts  # æ•°æ®åŒæ­¥
â”‚   â”‚   â”œâ”€â”€ PDFWorker.ts       # PDFç”Ÿæˆ
â”‚   â”‚   â””â”€â”€ CalculationWorker.ts # å¤æ‚è®¡ç®—
â”‚   â””â”€â”€ App.vue
```

## ğŸ”„ ååŒç¼–è¾‘ä¸æ•°æ®åŒæ­¥ç­–ç•¥

### 1. åŒæ¨¡å¼æ¶æ„è®¾è®¡

```typescript
// stores/sync.store.ts
export const useSyncStore = defineStore('sync', () => {
    const mode = ref<'online' | 'offline'>('online');
    const connectionStatus = ref<'connected' | 'disconnected' | 'connecting'>('connected');
    const pendingChanges = ref<LocalChange[]>([]);
    const conflictQueue = ref<Conflict[]>([]);
    const lastSyncTime = ref<number>(Date.now());

    // æ£€æµ‹ç½‘ç»œçŠ¶æ€
    const detectNetworkStatus = () => {
        const isOnline = navigator.onLine;
        mode.value = isOnline ? 'online' : 'offline';
        connectionStatus.value = isOnline ? 'connected' : 'disconnected';
        
        if (isOnline) {
            triggerSync();
        }
    };

    // åˆå§‹åŒ–ç½‘ç»œç›‘å¬
    const initNetworkListener = () => {
        window.addEventListener('online', () => {
            mode.value = 'online';
            connectionStatus.value = 'connecting';
            triggerSync();
        });

        window.addEventListener('offline', () => {
            mode.value = 'offline';
            connectionStatus.value = 'disconnected';
            notifyOfflineMode();
        });

        // å¿ƒè·³æ£€æµ‹
        setInterval(() => {
            if (mode.value === 'online') {
                checkServerHealth();
            }
        }, 30000);
    };

    // è§¦å‘æ•°æ®åŒæ­¥
    const triggerSync = async () => {
        if (mode.value === 'offline' || pendingChanges.value.length === 0) return;

        connectionStatus.value = 'connecting';
        
        try {
            // æ‰¹é‡å¤„ç†å¾…åŒæ­¥å˜æ›´
            const changesToSync = [...pendingChanges.value];
            const batchId = uuidv4();
            
            const results = await Promise.allSettled(
                changesToSync.map(change => syncChangeToServer(change))
            );

            // å¤„ç†åŒæ­¥ç»“æœ
            await processSyncResults(results, batchId);
            
            lastSyncTime.value = Date.now();
            connectionStatus.value = 'connected';
            
        } catch (error) {
            console.error('åŒæ­¥å¤±è´¥:', error);
            connectionStatus.value = 'disconnected';
            mode.value = 'offline';
            enqueueRetry();
        }
    };

    return {
        mode,
        connectionStatus,
        pendingChanges,
        conflictQueue,
        lastSyncTime,
        detectNetworkStatus,
        initNetworkListener,
        triggerSync
    };
});
```

### 2. ç¦»çº¿æ¨¡å¼ - IndexedDBç­–ç•¥

```typescript
// utils/sync/OfflineManager.ts
export class OfflineManager {
    private db: IDBDatabase;
    private readonly DB_NAME = 'PisteMasterOffline';
    private readonly DB_VERSION = 3;
    
    // æ•°æ®è¡¨ç»“æ„
    private readonly STORES = {
        TOURNAMENTS: 'tournaments',
        MATCHES: 'matches',
        FENCERS: 'fencers',
        CHANGES: 'pending_changes',
        CONFLICTS: 'conflicts',
        METADATA: 'metadata'
    };

    constructor() {
        this.initDB();
    }

    private async initDB(): Promise<void> {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);
            
            request.onerror = () => reject(request.error);
            
            request.onsuccess = () => {
                this.db = request.result;
                this.migrateLegacyData();
                resolve();
            };
            
            request.onupgradeneeded = (event) => {
                const db = request.result;
                this.createStores(db);
            };
        });
    }

    private createStores(db: IDBDatabase): void {
        // åˆ›å»ºæ•°æ®å­˜å‚¨è¡¨
        if (!db.objectStoreNames.contains(this.STORES.TOURNAMENTS)) {
            const tournamentStore = db.createObjectStore(this.STORES.TOURNAMENTS, { keyPath: 'id' });
            tournamentStore.createIndex('updatedAt', 'updatedAt', { unique: false });
        }

        if (!db.objectStoreNames.contains(this.STORES.CHANGES)) {
            const changeStore = db.createObjectStore(this.STORES.CHANGES, { 
                keyPath: 'id',
                autoIncrement: true 
            });
            changeStore.createIndex('entityType', 'entityType', { unique: false });
            changeStore.createIndex('entityId', 'entityId', { unique: false });
            changeStore.createIndex('timestamp', 'timestamp', { unique: false });
            changeStore.createIndex('status', 'status', { unique: false });
        }

        if (!db.objectStoreNames.contains(this.STORES.CONFLICTS)) {
            const conflictStore = db.createObjectStore(this.STORES.CONFLICTS, { 
                keyPath: 'id',
                autoIncrement: true 
            });
            conflictStore.createIndex('resolved', 'resolved', { unique: false });
        }

        // åˆ›å»ºå…ƒæ•°æ®è¡¨
        if (!db.objectStoreNames.contains(this.STORES.METADATA)) {
            const metadataStore = db.createObjectStore(this.STORES.METADATA, { keyPath: 'key' });
        }
    }

    // è®°å½•æœ¬åœ°å˜æ›´
    async recordChange(change: LocalChange): Promise<string> {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([this.STORES.CHANGES], 'readwrite');
            const store = transaction.objectStore(this.STORES.CHANGES);
            
            const changeRecord: ChangeRecord = {
                ...change,
                id: uuidv4(),
                timestamp: Date.now(),
                status: 'pending',
                retryCount: 0
            };
            
            const request = store.add(changeRecord);
            
            request.onsuccess = () => {
                // åŒæ—¶æ›´æ–°æœ¬åœ°æ•°æ®ç¼“å­˜
                this.updateLocalCache(change);
                resolve(changeRecord.id);
            };
            
            request.onerror = () => reject(request.error);
        });
    }

    // è·å–å¾…åŒæ­¥å˜æ›´
    async getPendingChanges(limit: number = 100): Promise<ChangeRecord[]> {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([this.STORES.CHANGES], 'readonly');
            const store = transaction.objectStore(this.STORES.CHANGES);
            const index = store.index('status');
            
            const request = index.getAll('pending');
            
            request.onsuccess = () => {
                const changes = request.result
                    .sort((a, b) => a.timestamp - b.timestamp)
                    .slice(0, limit);
                resolve(changes);
            };
            
            request.onerror = () => reject(request.error);
        });
    }

    // æ›´æ–°æœ¬åœ°ç¼“å­˜
    private async updateLocalCache(change: LocalChange): Promise<void> {
        const { entityType, entityId, operation, data } = change;
        
        const storeName = this.getStoreNameForEntity(entityType);
        if (!storeName) return;
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            
            switch (operation) {
                case 'create':
                case 'update':
                    store.put({
                        ...data,
                        id: entityId,
                        _localVersion: data.version || 1,
                        _lastModified: Date.now()
                    });
                    break;
                    
                case 'delete':
                    store.delete(entityId);
                    break;
            }
            
            transaction.oncomplete = () => resolve();
            transaction.onerror = () => reject(transaction.error);
        });
    }

    // æ ‡è®°å˜æ›´çŠ¶æ€
    async markChangeStatus(changeId: string, status: ChangeStatus, error?: string): Promise<void> {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([this.STORES.CHANGES], 'readwrite');
            const store = transaction.objectStore(this.STORES.CHANGES);
            
            const getRequest = store.get(changeId);
            
            getRequest.onsuccess = () => {
                const change = getRequest.result;
                if (!change) {
                    resolve();
                    return;
                }
                
                change.status = status;
                change.syncedAt = status === 'synced' ? Date.now() : undefined;
                change.error = error;
                
                if (status === 'failed') {
                    change.retryCount = (change.retryCount || 0) + 1;
                }
                
                const updateRequest = store.put(change);
                updateRequest.onsuccess = () => resolve();
                updateRequest.onerror = () => reject(updateRequest.error);
            };
            
            getRequest.onerror = () => reject(getRequest.error);
        });
    }

    // å†²çªæ£€æµ‹ä¸è®°å½•
    async recordConflict(conflict: Conflict): Promise<string> {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([this.STORES.CONFLICTS], 'readwrite');
            const store = transaction.objectStore(this.STORES.CONFLICTS);
            
            const conflictRecord = {
                ...conflict,
                id: uuidv4(),
                createdAt: Date.now(),
                resolved: false,
                resolution: null
            };
            
            const request = store.add(conflictRecord);
            
            request.onsuccess = () => {
                // è§¦å‘å†²çªè§£å†³ç•Œé¢
                this.notifyConflict(conflictRecord);
                resolve(conflictRecord.id);
            };
            
            request.onerror = () => reject(request.error);
        });
    }

    // è·å–æœªè§£å†³å†²çª
    async getUnresolvedConflicts(): Promise<Conflict[]> {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([this.STORES.CONFLICTS], 'readonly');
            const store = transaction.objectStore(this.STORES.CONFLICTS);
            const index = store.index('resolved');
            
            const request = index.getAll(false);
            
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    private getStoreNameForEntity(entityType: string): string | null {
        const mapping: Record<string, string> = {
            'tournament': this.STORES.TOURNAMENTS,
            'match': this.STORES.MATCHES,
            'fencer': this.STORES.FENCERS
        };
        return mapping[entityType] || null;
    }
}
```

### 3. åœ¨çº¿æ¨¡å¼ - å®æ—¶ååŒç¼–è¾‘ï¼ˆCRDTï¼‰

```typescript
// api/sync/SyncManager.ts
export class SyncManager {
    private doc: Y.Doc;
    private wsProvider: WebsocketProvider | null = null;
    private indexeddbProvider: IndexeddbPersistence | null = null;
    private isInitialized = false;
    
    // ä¸åŒç±»å‹æ•°æ®çš„ååŒç­–ç•¥
    private readonly SYNC_STRATEGIES = {
        // æ¯”èµ›åˆ†æ•° - éœ€è¦ä¸¥æ ¼é¡ºåºï¼Œä½¿ç”¨é”æœºåˆ¶
        MATCH_SCORE: {
            type: 'locking',
            timeout: 30000, // 30ç§’é”è¶…æ—¶
            conflictResolution: 'serverWins'
        },
        // å¯¹é˜µè¡¨ç¼–æ’ - éœ€è¦ååŒç¼–è¾‘ï¼Œä½¿ç”¨OTè½¬æ¢
        BRACKET: {
            type: 'operational',
            conflictResolution: 'mergeLastWriteWins'
        },
        // é€‰æ‰‹ä¿¡æ¯ - å…è®¸å¹¶è¡Œç¼–è¾‘ï¼Œå†²çªæ—¶åˆå¹¶
        FENCER_INFO: {
            type: 'crdt',
            conflictResolution: 'fieldLevelMerge'
        },
        // è£åˆ¤åˆ†é… - éœ€è¦äº’æ–¥ï¼Œä½¿ç”¨ä¹è§‚é”
        REFEREE_ASSIGNMENT: {
            type: 'optimistic',
            conflictResolution: 'manual'
        }
    };

    constructor(private tournamentId: string) {
        this.doc = new Y.Doc();
        this.setupProviders();
    }

    private setupProviders(): void {
        // WebSocketæä¾›è€… - ç”¨äºå®æ—¶ååŒ
        if (import.meta.env.VITE_WS_URL) {
            this.wsProvider = new WebsocketProvider(
                import.meta.env.VITE_WS_URL,
                `tournament-${this.tournamentId}`,
                this.doc
            );
            
            // ç›‘å¬è¿æ¥çŠ¶æ€
            this.wsProvider.on('status', (event: { status: string }) => {
                this.handleConnectionStatus(event.status);
            });
            
            // ç›‘å¬ååŒäº‹ä»¶
            this.wsProvider.on('sync', (isSynced: boolean) => {
                if (isSynced) {
                    this.handleInitialSync();
                }
            });
        }

        // IndexedDBæä¾›è€… - ç”¨äºæœ¬åœ°æŒä¹…åŒ–
        this.indexeddbProvider = new IndexeddbPersistence(
            `tournament-${this.tournamentId}`,
            this.doc
        );
        
        this.indexeddbProvider.whenSynced.then(() => {
            console.log('æœ¬åœ°æ•°æ®å·²åŠ è½½');
        });
    }

    // åˆå§‹åŒ–æ•°æ®æ˜ å°„
    async initialize(): Promise<void> {
        if (this.isInitialized) return;
        
        // å®šä¹‰æ•°æ®ç»“æ„
        this.doc.getMap('tournament');
        this.doc.getArray('matches');
        this.doc.getMap('fencers');
        this.doc.getArray('pendingOperations');
        
        // ç›‘å¬æ•°æ®å˜åŒ–
        this.doc.on('update', (update: Uint8Array, origin: any) => {
            this.handleUpdate(update, origin);
        });
        
        // è®¾ç½®ååŒæ“ä½œå¤„ç†å™¨
        this.setupOperationHandlers();
        
        this.isInitialized = true;
    }

    // æ“ä½œå¤„ç†å™¨
    private setupOperationHandlers(): void {
        // åˆ†æ•°æ›´æ–°å¤„ç†å™¨
        this.registerHandler('scoreUpdate', async (data, origin) => {
            const matchId = data.matchId;
            const lockKey = `match_${matchId}_score_lock`;
            
            // å°è¯•è·å–é”
            const hasLock = await this.acquireLock(lockKey, origin);
            if (!hasLock) {
                throw new Error('æ— æ³•è·å–åˆ†æ•°æ›´æ–°é”ï¼Œè¯·ç¨åé‡è¯•');
            }
            
            try {
                // åº”ç”¨åˆ†æ•°æ›´æ–°
                const matches = this.doc.getArray('matches');
                const matchIndex = this.findMatchIndex(matches, matchId);
                
                if (matchIndex === -1) {
                    throw new Error(`æ¯”èµ› ${matchId} ä¸å­˜åœ¨`);
                }
                
                // éªŒè¯åˆ†æ•°é€»è¾‘ï¼ˆå¦‚å‡»å‰‘è§„åˆ™ï¼‰
                if (!this.validateScore(data.newScore)) {
                    throw new Error('æ— æ•ˆçš„åˆ†æ•°æ›´æ–°');
                }
                
                // æ›´æ–°åˆ†æ•°
                const transaction = this.doc.transact();
                matches.delete(matchIndex);
                matches.insert(matchIndex, [{
                    ...matches.get(matchIndex),
                    score: data.newScore,
                    updatedBy: origin,
                    updatedAt: Date.now(),
                    version: (matches.get(matchIndex).version || 0) + 1
                }]);
                
                // å¹¿æ’­æ›´æ–°
                this.broadcastUpdate('scoreUpdate', {
                    matchId,
                    score: data.newScore,
                    timestamp: Date.now()
                });
                
            } finally {
                // é‡Šæ”¾é”
                await this.releaseLock(lockKey, origin);
            }
        });
        
        // å¯¹é˜µè¡¨æ›´æ–°å¤„ç†å™¨
        this.registerHandler('bracketUpdate', async (data, origin) => {
            // å¯¹é˜µè¡¨ä½¿ç”¨OTç®—æ³•ï¼Œè‡ªåŠ¨è§£å†³å†²çª
            const bracket = this.doc.getMap('bracket');
            const transaction = this.doc.transact();
            
            // åº”ç”¨å¯¹é˜µè¡¨æ›´æ–°
            data.changes.forEach((change: BracketChange) => {
                this.applyBracketChange(bracket, change);
            });
            
            // è®°å½•æ“ä½œå†å²
            this.recordOperation('bracketUpdate', data, origin);
        });
    }

    // å†²çªæ£€æµ‹ä¸è§£å†³
    private async detectAndResolveConflicts(
        localData: any,
        remoteData: any,
        strategy: SyncStrategy
    ): Promise<ConflictResolution> {
        switch (strategy.conflictResolution) {
            case 'serverWins':
                return {
                    resolvedData: remoteData,
                    resolution: 'server',
                    conflicts: []
                };
                
            case 'clientWins':
                return {
                    resolvedData: localData,
                    resolution: 'client',
                    conflicts: []
                };
                
            case 'manual':
                // éœ€è¦äººå·¥å¹²é¢„çš„å†²çª
                const conflicts = this.detectFieldLevelConflicts(localData, remoteData);
                return {
                    resolvedData: null,
                    resolution: 'manual',
                    conflicts
                };
                
            case 'mergeLastWriteWins':
                return this.mergeLastWriteWins(localData, remoteData);
                
            case 'fieldLevelMerge':
                return this.mergeFieldLevel(localData, remoteData);
        }
    }

    // å­—æ®µçº§åˆå¹¶ç­–ç•¥
    private mergeFieldLevel(localData: any, remoteData: any): ConflictResolution {
        const conflicts: FieldConflict[] = [];
        const result = { ...remoteData };
        
        Object.keys(localData).forEach(key => {
            const localValue = localData[key];
            const remoteValue = remoteData[key];
            
            if (localValue === undefined || remoteValue === undefined) {
                // å­—æ®µä¸å­˜åœ¨äºä¸€æ–¹ï¼Œç›´æ¥é‡‡ç”¨å­˜åœ¨æ–¹
                result[key] = localValue || remoteValue;
            } else if (this.isEqual(localValue, remoteValue)) {
                // å­—æ®µå€¼ç›¸åŒï¼Œæ— éœ€å¤„ç†
                result[key] = localValue;
            } else if (this.isPrimitive(localValue) && this.isPrimitive(remoteValue)) {
                // åŸºç¡€ç±»å‹å†²çªï¼Œé‡‡ç”¨æ—¶é—´æˆ³è¾ƒæ–°çš„
                const localTimestamp = localData._timestamp?.[key] || 0;
                const remoteTimestamp = remoteData._timestamp?.[key] || 0;
                
                if (localTimestamp > remoteTimestamp) {
                    result[key] = localValue;
                    conflicts.push({
                        field: key,
                        localValue,
                        remoteValue,
                        resolvedValue: localValue,
                        resolution: 'clientNewer'
                    });
                } else {
                    conflicts.push({
                        field: key,
                        localValue,
                        remoteValue,
                        resolvedValue: remoteValue,
                        resolution: 'serverNewer'
                    });
                }
            } else if (Array.isArray(localValue) && Array.isArray(remoteValue)) {
                // æ•°ç»„åˆå¹¶ï¼ˆå¦‚å¯¹é˜µè¡¨ï¼‰
                result[key] = this.mergeArrays(localValue, remoteValue, conflicts, key);
            } else if (typeof localValue === 'object' && typeof remoteValue === 'object') {
                // å¯¹è±¡é€’å½’åˆå¹¶
                const nestedResult = this.mergeFieldLevel(localValue, remoteValue);
                result[key] = nestedResult.resolvedData;
                conflicts.push(...nestedResult.conflicts.map(c => ({
                    ...c,
                    field: `${key}.${c.field}`
                })));
            }
        });
        
        return {
            resolvedData: result,
            resolution: 'merged',
            conflicts
        };
    }

    // åˆ†å¸ƒå¼é”æœºåˆ¶
    private async acquireLock(resource: string, clientId: string, timeout: number = 30000): Promise<boolean> {
        const lockKey = `lock_${resource}`;
        const lockMap = this.doc.getMap('locks');
        
        const existingLock = lockMap.get(lockKey);
        const now = Date.now();
        
        if (existingLock) {
            // æ£€æŸ¥é”æ˜¯å¦è¿‡æœŸ
            if (now - existingLock.timestamp < timeout) {
                return false; // é”è¢«å…¶ä»–å®¢æˆ·ç«¯æŒæœ‰
            }
            // é”å·²è¿‡æœŸï¼Œå¯ä»¥è·å–
        }
        
        // è®¾ç½®æ–°é”
        const transaction = this.doc.transact();
        lockMap.set(lockKey, {
            clientId,
            timestamp: now,
            timeout
        });
        
        // ç­‰å¾…ä¸€å°æ®µæ—¶é—´ç¡®è®¤é”å·²åŒæ­¥
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // éªŒè¯é”æ˜¯å¦è¢«å…¶ä»–å®¢æˆ·ç«¯æŠ¢å 
        const finalLock = lockMap.get(lockKey);
        return finalLock?.clientId === clientId;
    }
    
    private async releaseLock(resource: string, clientId: string): Promise<void> {
        const lockKey = `lock_${resource}`;
        const lockMap = this.doc.getMap('locks');
        
        const lock = lockMap.get(lockKey);
        if (lock && lock.clientId === clientId) {
            lockMap.delete(lockKey);
        }
    }

    // å†²çªè§£å†³ç•Œé¢æ•°æ®ç”Ÿæˆ
    generateConflictResolutionData(conflict: Conflict): ConflictUI {
        const localData = conflict.localVersion.data;
        const remoteData = conflict.remoteVersion.data;
        
        return {
            id: conflict.id,
            entityType: conflict.entityType,
            entityId: conflict.entityId,
            description: this.getConflictDescription(conflict),
            timestamp: conflict.timestamp,
            changes: {
                local: this.extractChanges(localData, remoteData),
                remote: this.extractChanges(remoteData, localData)
            },
            suggestedResolution: this.suggestResolution(conflict),
            resolutionOptions: this.getResolutionOptions(conflict),
            severity: this.getConflictSeverity(conflict)
        };
    }
}
```

### 4. å†²çªè§£å†³ç­–ç•¥ä¸UIç»„ä»¶

```vue
<!-- components/conflict/ConflictResolver.vue -->
<template>
    <div class="conflict-resolver" v-if="activeConflicts.length > 0">
        <!-- å†²çªæç¤ºæ¡ -->
        <div class="conflict-alert" :class="`severity-${highestSeverity}`">
            <div class="alert-content">
                <el-icon :size="20">
                    <Warning />
                </el-icon>
                <span class="message">
                    {{ t('conflict.detected', { count: activeConflicts.length }) }}
                </span>
                <el-button type="primary" size="small" @click="showResolverPanel = true">
                    {{ t('conflict.resolveNow') }}
                </el-button>
            </div>
        </div>

        <!-- å†²çªè§£å†³é¢æ¿ -->
        <el-drawer
            v-model="showResolverPanel"
            :title="t('conflict.resolverTitle')"
            size="80%"
            direction="rtl"
            destroy-on-close
        >
            <div class="conflict-list">
                <el-scrollbar height="calc(100vh - 200px)">
                    <div
                        v-for="conflict in activeConflicts"
                        :key="conflict.id"
                        class="conflict-item"
                    >
                        <!-- å†²çªè¯¦æƒ… -->
                        <div class="conflict-header">
                            <el-tag :type="getSeverityTag(conflict.severity)">
                                {{ t(`conflict.severity.${conflict.severity}`) }}
                            </el-tag>
                            <span class="entity-name">
                                {{ getEntityName(conflict.entityType, conflict.entityId) }}
                            </span>
                            <span class="conflict-time">
                                {{ formatTime(conflict.timestamp) }}
                            </span>
                        </div>

                        <!-- å†²çªæè¿° -->
                        <div class="conflict-description">
                            {{ conflict.description }}
                        </div>

                        <!-- å˜æ›´å¯¹æ¯” -->
                        <div class="changes-comparison">
                            <div class="change-column">
                                <div class="column-header local">
                                    <el-icon><User /></el-icon>
                                    <span>{{ t('conflict.yourChanges') }}</span>
                                </div>
                                <div class="change-list">
                                    <div
                                        v-for="(change, index) in conflict.changes.local"
                                        :key="`local-${index}`"
                                        class="change-item"
                                    >
                                        <div class="field-name">{{ change.field }}</div>
                                        <div class="field-value">
                                            <span class="old-value" v-if="change.oldValue">
                                                {{ formatValue(change.oldValue) }} â†’
                                            </span>
                                            <span class="new-value">
                                                {{ formatValue(change.newValue) }}
                                            </span>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="change-column">
                                <div class="column-header remote">
                                    <el-icon><Cloud /></el-icon>
                                    <span>{{ t('conflict.serverChanges') }}</span>
                                </div>
                                <div class="change-list">
                                    <div
                                        v-for="(change, index) in conflict.changes.remote"
                                        :key="`remote-${index}`"
                                        class="change-item"
                                    >
                                        <div class="field-name">{{ change.field }}</div>
                                        <div class="field-value">
                                            <span class="old-value" v-if="change.oldValue">
                                                {{ formatValue(change.oldValue) }} â†’
                                            </span>
                                            <span class="new-value">
                                                {{ formatValue(change.newValue) }}
                                            </span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- è§£å†³é€‰é¡¹ -->
                        <div class="resolution-options">
                            <div class="suggestion" v-if="conflict.suggestedResolution">
                                <el-icon><Lightbulb /></el-icon>
                                <span>{{ conflict.suggestedResolution }}</span>
                            </div>

                            <div class="actions">
                                <el-radio-group v-model="selectedResolutions[conflict.id]">
                                    <el-radio
                                        v-for="option in conflict.resolutionOptions"
                                        :key="option.value"
                                        :label="option.value"
                                    >
                                        {{ option.label }}
                                    </el-radio>
                                </el-radio-group>

                                <div class="action-buttons">
                                    <el-button
                                        type="primary"
                                        :loading="resolvingConflicts[conflict.id]"
                                        @click="resolveConflict(conflict.id)"
                                    >
                                        {{ t('conflict.applyResolution') }}
                                    </el-button>
                                    <el-button @click="ignoreConflict(conflict.id)">
                                        {{ t('conflict.ignore') }}
                                    </el-button>
                                </div>
                            </div>
                        </div>
                    </div>
                </el-scrollbar>

                <!-- æ‰¹é‡æ“ä½œ -->
                <div class="batch-actions" v-if="activeConflicts.length > 1">
                    <el-button @click="applyAllLocal">
                        {{ t('conflict.applyAllLocal') }}
                    </el-button>
                    <el-button @click="applyAllRemote">
                        {{ t('conflict.applyAllRemote') }}
                    </el-button>
                    <el-button type="danger" @click="ignoreAllConflicts">
                        {{ t('conflict.ignoreAll') }}
                    </el-button>
                </div>
            </div>
        </el-drawer>
    </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue';
import { useSyncStore } from '@/stores/sync.store';
import { useConflictStore } from '@/stores/conflict.store';
import { useI18n } from 'vue-i18n';

const { t } = useI18n();
const syncStore = useSyncStore();
const conflictStore = useConflictStore();

const showResolverPanel = ref(false);
const selectedResolutions = ref<Record<string, string>>({});
const resolvingConflicts = ref<Record<string, boolean>>({});

const activeConflicts = computed(() => conflictStore.activeConflicts);

const highestSeverity = computed(() => {
    if (activeConflicts.value.length === 0) return 'low';
    const severities = activeConflicts.value.map(c => c.severity);
    if (severities.includes('critical')) return 'critical';
    if (severities.includes('high')) return 'high';
    if (severities.includes('medium')) return 'medium';
    return 'low';
});

// è§£å†³å•ä¸ªå†²çª
const resolveConflict = async (conflictId: string) => {
    const resolution = selectedResolutions.value[conflictId];
    if (!resolution) return;

    resolvingConflicts.value[conflictId] = true;
    
    try {
        await conflictStore.resolveConflict(conflictId, resolution);
        delete selectedResolutions.value[conflictId];
        
        // å¦‚æœæ‰€æœ‰å†²çªå·²è§£å†³ï¼Œå…³é—­é¢æ¿
        if (activeConflicts.value.length === 0) {
            showResolverPanel.value = false;
        }
    } catch (error) {
        console.error('è§£å†³å†²çªå¤±è´¥:', error);
    } finally {
        resolvingConflicts.value[conflictId] = false;
    }
};

// æ‰¹é‡æ“ä½œ
const applyAllLocal = async () => {
    for (const conflict of activeConflicts.value) {
        selectedResolutions.value[conflict.id] = 'useLocal';
        await resolveConflict(conflict.id);
    }
};

const applyAllRemote = async () => {
    for (const conflict of activeConflicts.value) {
        selectedResolutions.value[conflict.id] = 'useRemote';
        await resolveConflict(conflict.id);
    }
};

const ignoreAllConflicts = () => {
    conflictStore.ignoreAllConflicts();
    showResolverPanel.value = false;
};
</script>

<style scoped lang="scss">
.conflict-resolver {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 9999;
}

.conflict-alert {
    padding: 12px 24px;
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
    transition: all 0.3s ease;
    
    &.severity-critical {
        background: linear-gradient(135deg, #ff4d4f, #cf1322);
    }
    
    &.severity-high {
        background: linear-gradient(135deg, #ffa940, #fa8c16);
    }
    
    &.severity-medium {
        background: linear-gradient(135deg, #ffc53d, #faad14);
    }
    
    &.severity-low {
        background: linear-gradient(135deg, #73d13d, #389e0d);
    }
    
    .alert-content {
        display: flex;
        align-items: center;
        gap: 12px;
        max-width: 1200px;
        width: 100%;
        
        .message {
            flex: 1;
            font-weight: 500;
        }
    }
}

.conflict-list {
    padding: 20px;
    
    .conflict-item {
        background: white;
        border: 1px solid #e8e8e8;
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 16px;
        
        .conflict-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
            
            .entity-name {
                font-weight: 600;
                font-size: 16px;
                color: #262626;
            }
            
            .conflict-time {
                margin-left: auto;
                color: #8c8c8c;
                font-size: 12px;
            }
        }
        
        .conflict-description {
            color: #595959;
            margin-bottom: 20px;
            line-height: 1.6;
        }
        
        .changes-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
            
            .change-column {
                border: 1px solid #f0f0f0;
                border-radius: 6px;
                overflow: hidden;
                
                .column-header {
                    padding: 12px;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    font-weight: 600;
                    
                    &.local {
                        background: #e6f7ff;
                        color: #1890ff;
                    }
                    
                    &.remote {
                        background: #f6ffed;
                        color: #52c41a;
                    }
                }
                
                .change-list {
                    padding: 12px;
                    
                    .change-item {
                        display: flex;
                        justify-content: space-between;
                        padding: 8px 0;
                        border-bottom: 1px solid #f0f0f0;
                        
                        &:last-child {
                            border-bottom: none;
                        }
                        
                        .field-name {
                            color: #595959;
                            font-weight: 500;
                        }
                        
                        .field-value {
                            .old-value {
                                color: #8c8c8c;
                                text-decoration: line-through;
                                margin-right: 4px;
                            }
                            
                            .new-value {
                                color: #1890ff;
                                font-weight: 500;
                            }
                        }
                    }
                }
            }
        }
        
        .resolution-options {
            .suggestion {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 12px;
                background: #fffbe6;
                border: 1px solid #ffe58f;
                border-radius: 6px;
                margin-bottom: 16px;
                color: #d48806;
            }
            
            .actions {
                .action-buttons {
                    display: flex;
                    gap: 12px;
                    margin-top: 16px;
                }
            }
        }
    }
}

.batch-actions {
    display: flex;
    gap: 12px;
    padding: 20px 0;
    border-top: 1px solid #f0f0f0;
    margin-top: 20px;
}
</style>
```

### 5. æ•°æ®åŒæ­¥çŠ¶æ€ç®¡ç†

```typescript
// stores/conflict.store.ts
export const useConflictStore = defineStore('conflict', () => {
    const conflicts = ref<ConflictUI[]>([]);
    const ignoredConflicts = ref<string[]>([]);
    const resolutionHistory = ref<ConflictResolutionRecord[]>([]);

    // æ·»åŠ å†²çª
    const addConflict = (conflictData: Conflict) => {
        // æ£€æŸ¥æ˜¯å¦å·²å¿½ç•¥
        if (ignoredConflicts.value.includes(conflictData.id)) {
            return;
        }

        // ç”ŸæˆUIæ•°æ®
        const conflictUI = conflictService.generateConflictResolutionData(conflictData);
        
        // æ·»åŠ åˆ°åˆ—è¡¨
        if (!conflicts.value.some(c => c.id === conflictUI.id)) {
            conflicts.value.push(conflictUI);
            
            // å‘é€é€šçŸ¥
            sendConflictNotification(conflictUI);
        }
    };

    // è§£å†³å†²çª
    const resolveConflict = async (conflictId: string, resolution: string) => {
        const conflict = conflicts.value.find(c => c.id === conflictId);
        if (!conflict) return;

        try {
            // åº”ç”¨è§£å†³æ–¹æ¡ˆ
            const result = await conflictService.applyResolution(conflictId, resolution);
            
            // è®°å½•è§£å†³å†å²
            const record: ConflictResolutionRecord = {
                conflictId,
                resolution,
                resolvedAt: Date.now(),
                result,
                resolvedBy: useAuthStore().currentUser?.id || 'system'
            };
            
            resolutionHistory.value.push(record);
            
            // ä»æ´»åŠ¨åˆ—è¡¨ä¸­ç§»é™¤
            conflicts.value = conflicts.value.filter(c => c.id !== conflictId);
            
            // å‘é€è§£å†³äº‹ä»¶
            emitConflictResolved(conflictId, resolution);
            
        } catch (error) {
            console.error(`è§£å†³å†²çª ${conflictId} å¤±è´¥:`, error);
            throw error;
        }
    };

    // å¿½ç•¥å†²çª
    const ignoreConflict = (conflictId: string) => {
        ignoredConflicts.value.push(conflictId);
        conflicts.value = conflicts.value.filter(c => c.id !== conflictId);
    };

    // è·å–æ´»åŠ¨å†²çª
    const activeConflicts = computed(() => {
        return conflicts.value.filter(c => !ignoredConflicts.value.includes(c.id));
    });

    // æŒ‰ä¸¥é‡æ€§è¿‡æ»¤
    const criticalConflicts = computed(() => {
        return activeConflicts.value.filter(c => c.severity === 'critical');
    });

    return {
        conflicts,
        ignoredConflicts,
        resolutionHistory,
        activeConflicts,
        criticalConflicts,
        addConflict,
        resolveConflict,
        ignoreConflict
    };
});
```

## ğŸ–¨ï¸ ä¸“ä¸šæ‰“å°ç³»ç»Ÿ

### 1. PDFç”Ÿæˆå¼•æ“

```typescript
// printing/generators/BracketGenerator.ts
export class BracketGenerator {
    private doc: jsPDF;
    private currentY = 0;
    private readonly MARGIN = 20;
    private readonly PAGE_WIDTH = 210; // A4 width in mm
    private readonly PAGE_HEIGHT = 297; // A4 height in mm

    constructor(options: BracketOptions = {}) {
        this.doc = new jsPDF({
            orientation: options.orientation || 'portrait',
            unit: 'mm',
            format: 'a4'
        });

        // è®¾ç½®ä¸­æ–‡å­—ä½“
        this.setupChineseFont();
    }

    private setupChineseFont() {
        // æ·»åŠ ä¸­æ–‡å­—ä½“æ”¯æŒ
        const fontPath = '/fonts/NotoSansSC-Regular.ttf';
        this.doc.addFont(fontPath, 'NotoSansSC', 'normal');
        this.doc.setFont('NotoSansSC');
    }

    generateEliminationBracket(matches: MatchNode[], options: BracketLayoutOptions) {
        const {title, tournamentName, eventName, date} = options;

        // æ ‡é¢˜é¡µ
        this.addTitlePage(title, tournamentName, eventName, date);
        this.doc.addPage();

        // è®¡ç®—å¯¹é˜µè¡¨å¸ƒå±€
        const bracketLayout = this.calculateBracketLayout(matches);

        // ç»˜åˆ¶å¯¹é˜µè¡¨
        this.drawBracket(bracketLayout);

        // æ·»åŠ é¡µè„š
        this.addFooter();

        return this.doc;
    }

    private drawBracket(layout: BracketLayout) {
        const cellWidth = 50;
        const cellHeight = 15;
        const verticalSpacing = 10;
        const horizontalSpacing = 20;

        layout.rounds.forEach((round, roundIndex) => {
            round.matches.forEach((match, matchIndex) => {
                const x = this.MARGIN + roundIndex * (cellWidth + horizontalSpacing);
                const y = this.MARGIN + matchIndex * (cellHeight + verticalSpacing);

                // ç»˜åˆ¶æ¯”èµ›æ¡†
                this.drawMatchBox(x, y, cellWidth, cellHeight, match);

                // ç»˜åˆ¶è¿æ¥çº¿
                if (match.nextMatch) {
                    const nextX = x + cellWidth + horizontalSpacing;
                    const nextY = this.calculateNextMatchY(match, matchIndex, round);
                    this.drawConnector(x + cellWidth, y + cellHeight / 2, nextX, nextY);
                }
            });
        });
    }

    private drawMatchBox(x: number, y: number, width: number, height: number, match: MatchNode) {
        // ç»˜åˆ¶çŸ©å½¢
        this.doc.rect(x, y, width, height);

        // é€‰æ‰‹A
        this.doc.text(match.fencerA.name, x + 2, y + 5);
        this.doc.text(match.scoreA?.toString() || '', x + width - 10, y + 5);

        // é€‰æ‰‹B
        this.doc.text(match.fencerB.name, x + 2, y + 12);
        this.doc.text(match.scoreB?.toString() || '', x + width - 10, y + 12);

        // æ¯”èµ›ç¼–å·
        this.doc.setFontSize(8);
        this.doc.text(match.matchCode, x + 2, y - 2);
        this.doc.setFontSize(12);
    }

    private drawConnector(x1: number, y1: number, x2: number, y2: number) {
        // ç»˜åˆ¶è¿æ¥çº¿ï¼ˆè´å¡å°”æ›²çº¿ï¼‰
        const cp1x = x1 + 10;
        const cp1y = y1;
        const cp2x = x2 - 10;
        const cp2y = y2;

        this.doc.setDrawColor(0, 0, 0);
        this.doc.setLineWidth(0.5);
        this.doc.line(x1, y1, cp1x, cp1y);
        this.doc.line(cp2x, cp2y, x2, y2);

        // ç»˜åˆ¶æ›²çº¿
        this.doc.curve(cp1x, cp1y, cp2x, cp2y, x1, y1, x2, y2);
    }

    // ç”ŸæˆäºŒç»´ç 
    private addQRCode(url: string, x: number, y: number, size: number = 20) {
        const qrCodeData = QRCode.generatePNG(url, {
            errorCorrectionLevel: 'M',
            typeNumber: 4,
            size: size * 4 // æé«˜åˆ†è¾¨ç‡
        });

        const qrCodeBase64 = `data:image/png;base64,${btoa(qrCodeData)}`;
        this.doc.addImage(qrCodeBase64, 'PNG', x, y, size, size);
    }
}
```

### 2. æ‰“å°é˜Ÿåˆ—ç®¡ç†å™¨

```typescript
// printing/queue/PrintQueueManager.ts
export class PrintQueueManager {
    private queue: PrintJob[] = [];
    private isProcessing = false;
    private printers = new Map<string, Printer>();

    constructor() {
        // æ£€æµ‹å¯ç”¨æ‰“å°æœº
        this.detectPrinters();

        // ç›‘å¬æ‰“å°å®Œæˆäº‹ä»¶
        window.addEventListener('afterprint', () => {
            this.onPrintComplete();
        });
    }

    async addJob(job: PrintJob) {
        const jobWithId = {
            ...job,
            id: uuidv4(),
            status: 'queued' as const,
            createdAt: Date.now(),
            attempts: 0
        };

        this.queue.push(jobWithId);

        // å¦‚æœæ˜¯ç´§æ€¥ä»»åŠ¡ï¼ˆå¦‚æ¯”èµ›ç»“æœï¼‰ï¼Œç«‹å³å¤„ç†
        if (job.priority === 'urgent') {
            await this.processQueue();
        } else {
            this.scheduleProcessing();
        }

        return jobWithId.id;
    }

    private async processQueue() {
        if (this.isProcessing || this.queue.length === 0) return;

        this.isProcessing = true;

        while (this.queue.length > 0) {
            const job = this.queue[0];

            try {
                job.status = 'processing';
                job.startedAt = Date.now();

                await this.executePrintJob(job);

                // æ‰“å°æˆåŠŸ
                job.status = 'completed';
                job.completedAt = Date.now();
                this.queue.shift();

                // è§¦å‘æˆåŠŸäº‹ä»¶
                this.emitPrintEvent('success', job);

            } catch (error) {
                job.attempts++;
                job.lastError = error.message;

                if (job.attempts >= job.maxRetries) {
                    // è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°
                    job.status = 'failed';
                    this.queue.shift();
                    this.emitPrintEvent('failed', job);
                } else {
                    // é‡æ–°æ’é˜Ÿç­‰å¾…é‡è¯•
                    job.status = 'queued';
                    const backoffTime = Math.min(5000 * job.attempts, 60000);
                    setTimeout(() => this.processQueue(), backoffTime);
                }
            }
        }

        this.isProcessing = false;
    }

    private async executePrintJob(job: PrintJob) {
        switch (job.type) {
            case 'pdf':
                await this.printPDF(job);
                break;
            case 'thermal':
                await this.printThermal(job);
                break;
            case 'scorecard':
                await this.printScoreCard(job);
                break;
            default:
                throw new Error(`Unknown print type: ${job.type}`);
        }
    }

    private async printPDF(job: PDFPrintJob) {
        // ç”ŸæˆPDF
        const pdf = job.generator.generate();

        // å¦‚æœæ˜¯æµè§ˆå™¨æ‰“å°
        if (job.printerType === 'browser') {
            const pdfBlob = pdf.output('blob');
            const url = URL.createObjectURL(pdfBlob);

            const printWindow = window.open(url, '_blank');
            if (!printWindow) {
                throw new Error('æ— æ³•æ‰“å¼€æ‰“å°çª—å£ï¼Œè¯·æ£€æŸ¥å¼¹çª—é˜»æ­¢è®¾ç½®');
            }

            printWindow.onload = () => {
                printWindow.print();
            };

        } else if (job.printerType === 'network') {
            // å‘é€åˆ°ç½‘ç»œæ‰“å°æœº
            await this.sendToNetworkPrinter(job.printerId, pdf);
        }
    }

    private async printThermal(job: ThermalPrintJob) {
        // ä½¿ç”¨WebUSBæˆ–WebSocketè¿æ¥çƒ­æ•æ‰“å°æœº
        const printer = this.printers.get(job.printerId);
        if (!printer) throw new Error('æ‰“å°æœºæœªè¿æ¥');

        // ESC/POSæŒ‡ä»¤
        const commands = [
            '\x1B\x40', // åˆå§‹åŒ–
            '\x1B\x61\x01', // å±…ä¸­
            `TOURNAMENT: ${job.tournamentName}\n\n`,
            '\x1B\x45\x01', // åŠ ç²—
            `${job.matchCode}\n`,
            '\x1B\x45\x00', // å–æ¶ˆåŠ ç²—
            `Time: ${formatTime(job.startTime)}\n`,
            `Piste: ${job.pisteNumber}\n\n`,
            '\x1D\x21\x01', // åŒå€é«˜åº¦
            `${job.fencerA.name} vs ${job.fencerB.name}\n`,
            '\x1D\x21\x00',
            `Score: ${job.scoreA} - ${job.scoreB}\n\n`,
            '\x1B\x61\x00', // å·¦å¯¹é½
            `Referee: ${job.refereeName}\n`,
            `Printed: ${new Date().toLocaleString()}\n`,
            '\x1B\x69', // åˆ‡çº¸
        ];

        await printer.write(commands.join(''));
    }
}
```

## ğŸ¨ UI/UXè®¾è®¡ç³»ç»Ÿ

### 1. ä¸»é¢˜ä¸æ— éšœç¢è®¾è®¡

```scss
// styles/theme/_variables.scss
:root {
  // å‡»å‰‘ä¸»é¢˜è‰²
  --fencer-primary: #0066cc; // å›½é™…å‰‘è”è“
  --fencer-secondary: #cc0000; // çº¢ç‰Œçº¢
  --fencer-warning: #ffcc00; // é»„ç‰Œé»„
  --fencer-success: #00aa00; // æˆåŠŸç»¿
  --fencer-danger: #cc0000; // å±é™©çº¢

  // å¯¹æ¯”åº¦ç¡®ä¿æ— éšœç¢
  --text-primary: #000000;
  --text-secondary: #666666;
  --text-on-primary: #ffffff;
  --text-on-danger: #ffffff;

  // è§¦æ§ç›®æ ‡å°ºå¯¸
  --touch-target-min: 44px;
  --touch-target-ideal: 48px;

  // åŠ¨ç”»
  --transition-fast: 150ms;
  --transition-normal: 300ms;
  --transition-slow: 500ms;

  // å­—ä½“
  --font-family-base: 'Inter', 'Noto Sans SC', sans-serif;
  --font-family-mono: 'Roboto Mono', monospace;
}

// é«˜å¯¹æ¯”åº¦æ¨¡å¼
.high-contrast {
  --text-primary: #000000;
  --text-secondary: #333333;
  --fencer-primary: #0000aa;
  --fencer-secondary: #aa0000;
  --background-primary: #ffffff;
  --background-secondary: #f0f0f0;

  * {
    border-width: 2px !important;
  }
}

// æš—é»‘æ¨¡å¼ï¼ˆé€‚åˆæ¯”èµ›åœºé¦†ï¼‰
.dark-mode {
  --background-primary: #121212;
  --background-secondary: #1e1e1e;
  --text-primary: #ffffff;
  --text-secondary: #b0b0b0;
  --fencer-primary: #4dabf7;

  // é™ä½äº®åº¦ï¼Œå‡å°‘å¯¹è¿åŠ¨å‘˜å½±å“
  filter: brightness(0.9);
}
```

### 2. è£åˆ¤ç«¯ä¸“ç”¨æ ·å¼

```scss
// styles/referee.scss
.referee-interface {
  // é˜²è¯¯è§¦
  touch-action: manipulation;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;

  // å¤§è§¦æ§åŒºåŸŸ
  button, .touch-target {
    min-height: var(--touch-target-ideal);
    min-width: var(--touch-target-ideal);
    padding: 12px 24px;
    border-radius: 12px;
    font-size: 1.5rem;
    font-weight: 600;

    // é˜²æ­¢ç‚¹å‡»é«˜äº®
    -webkit-tap-highlight-color: transparent;

    // æŒ‰å‹æ•ˆæœ
    &:active {
      transform: scale(0.95);
      transition: transform var(--transition-fast);
    }

    // ç¦ç”¨çŠ¶æ€
    &:disabled {
      opacity: 0.5;
      filter: grayscale(0.5);
      pointer-events: none;
    }
  }

  // ç´§æ€¥æŒ‰é’®
  .emergency-button {
    background: linear-gradient(135deg, var(--fencer-danger), #ff3333);
    color: white;
    font-size: 2rem;
    padding: 24px;
    border: 4px solid white;
    box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);

    // é—ªçƒåŠ¨ç”»
    &.active {
      animation: pulse 1s infinite;
    }
  }

  // å¾—åˆ†æŒ‰é’®
  .score-button {
    font-size: 4rem;
    font-weight: 900;
    border: 6px solid currentColor;

    &.left {
      color: var(--fencer-primary);
    }

    &.right {
      color: var(--fencer-secondary);
    }

    // å¾—åˆ†åŠ¨ç”»
    &.scored {
      animation: scorePulse 0.5s;
    }
  }

  // æŒ¯åŠ¨åé¦ˆç±»
  .vibrate-on-tap {
    @media (hover: none) and (pointer: coarse) {
      &:active {
        // è§¦å‘è®¾å¤‡æŒ¯åŠ¨
      }
    }
  }
}

// åŠ¨ç”»å®šä¹‰
@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.7;
  }
}

@keyframes scorePulse {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.1);
  }
  100% {
    transform: scale(1);
  }
}

// æ‰‹åŠ¿æç¤º
.gesture-hint {
  position: fixed;
  bottom: 20px;
  right: 20px;
  background: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 16px;
  border-radius: 16px;
  backdrop-filter: blur(10px);
  z-index: 1000;

  .gesture-icon {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    margin-right: 12px;
  }
}
```

## ğŸ” å®‰å…¨ä¸å®¡è®¡

### 1. å‰ç«¯æ“ä½œå®¡è®¡

```typescript
// stores/audit.store.ts
export const useAuditStore = defineStore('audit', () => {
    const logs = ref<AuditLog[]>([]);
    const MAX_LOG_SIZE = 10000;

    // è®°å½•æ“ä½œ
    const logAction = (action: AuditAction, details: Record<string, any> = {}) => {
        const user = useAuthStore().currentUser;
        const log: AuditLog = {
            id: uuidv4(),
            timestamp: Date.now(),
            user: user ? {
                id: user.id,
                name: user.displayName,
                role: user.role
            } : undefined,
            action,
            details,
            context: {
                url: window.location.href,
                userAgent: navigator.userAgent,
                screen: `${window.screen.width}x${window.screen.height}`,
                online: navigator.onLine
            }
        };

        // æ·»åŠ åˆ°å†…å­˜
        logs.value.unshift(log);

        // é™åˆ¶æ—¥å¿—å¤§å°
        if (logs.value.length > MAX_LOG_SIZE) {
            logs.value = logs.value.slice(0, MAX_LOG_SIZE);
        }

        // æŒä¹…åŒ–åˆ°IndexedDB
        persistLog(log);

        // å‘é€åˆ°æœåŠ¡å™¨ï¼ˆå¦‚æœåœ¨çº¿ï¼‰
        if (navigator.onLine) {
            sendLogToServer(log);
        }

        return log;
    };

    // å…³é”®æ“ä½œè®°å½•
    const criticalActions = [
        'SCORE_UPDATE',
        'CARD_ISSUED',
        'MATCH_START',
        'MATCH_END',
        'BRACKET_MODIFICATION',
        'REFEREE_ASSIGNMENT',
        'HARDWARE_CONNECTION'
    ];

    // åˆ›å»ºå®¡è®¡ä¸­é—´ä»¶
    const createAuditMiddleware = (actionType: string) => {
        return (payload: any) => {
            // è®°å½•å‰å¿«ç…§
            const beforeSnapshot = captureSnapshot();

            // æ‰§è¡ŒåŸæ“ä½œ
            const result = originalFunction(payload);

            // è®°å½•åå¿«ç…§
            const afterSnapshot = captureSnapshot();

            // è®°å½•å®¡è®¡æ—¥å¿—
            logAction(actionType, {
                payload,
                before: beforeSnapshot,
                after: afterSnapshot,
                result
            });

            return result;
        };
    };

    // å¯¼å‡ºå®¡è®¡æ—¥å¿—
    const exportLogs = (format: 'json' | 'csv' | 'pdf') => {
        const data = logs.value;

        switch (format) {
            case 'json':
                return JSON.stringify(data, null, 2);
            case 'csv':
                return convertToCSV(data);
            case 'pdf':
                return generateAuditPDF(data);
        }
    };

    return {
        logs,
        logAction,
        createAuditMiddleware,
        exportLogs
    };
});
```

### 2. æ’¤é”€/é‡åšç³»ç»Ÿ

```typescript
// utils/undo/UndoManager.ts
export class UndoManager {
    private stack: UndoAction[] = [];
    private redoStack: UndoAction[] = [];
    private maxStackSize = 100;

    constructor(private store: any) {
        // ç›‘å¬çŠ¶æ€å˜åŒ–
        this.setupStoreListener();
    }

    private setupStoreListener() {
        // ä½¿ç”¨Proxyç›‘å¬çŠ¶æ€å˜åŒ–
        this.store.$subscribe((mutation, state) => {
            // å¿½ç•¥æŸäº›mutationï¼ˆå¦‚UIçŠ¶æ€ï¼‰
            if (this.shouldIgnoreMutation(mutation)) return;

            this.recordChange(mutation, state);
        });
    }

    recordChange(mutation: any, newState: any) {
        const action: UndoAction = {
            id: uuidv4(),
            type: mutation.type,
            payload: mutation.payload,
            timestamp: Date.now(),
            before: this.captureSnapshot(),
            after: newState
        };

        this.stack.push(action);
        this.redoStack = []; // æ¸…ç©ºé‡åšæ ˆ

        // é™åˆ¶æ ˆå¤§å°
        if (this.stack.length > this.maxStackSize) {
            this.stack.shift();
        }
    }

    undo() {
        if (this.stack.length === 0) return false;

        const action = this.stack.pop()!;
        this.redoStack.push(action);

        // æ¢å¤åˆ°ä¹‹å‰çš„çŠ¶æ€
        this.applySnapshot(action.before);

        // è®°å½•æ’¤é”€æ“ä½œ
        useAuditStore().logAction('UNDO_ACTION', {
            actionId: action.id,
            actionType: action.type
        });

        return true;
    }

    redo() {
        if (this.redoStack.length === 0) return false;

        const action = this.redoStack.pop()!;
        this.stack.push(action);

        // åº”ç”¨é‡åšçš„çŠ¶æ€
        this.applySnapshot(action.after);

        // è®°å½•é‡åšæ“ä½œ
        useAuditStore().logAction('REDO_ACTION', {
            actionId: action.id,
            actionType: action.type
        });

        return true;
    }

    // å¿«ç…§å·¥å…·
    private captureSnapshot(): StateSnapshot {
        return {
            timestamp: Date.now(),
            data: deepClone(this.store.$state),
            version: '1.0'
        };
    }

    private applySnapshot(snapshot: StateSnapshot) {
        Object.keys(snapshot.data).forEach(key => {
            this.store.$state[key] = snapshot.data[key];
        });
    }
}
```

## ğŸ¯ æ€»ç»“

è¿™ä¸ªå¢å¼ºç‰ˆçš„å‰ç«¯æ¶æ„è®¾è®¡é’ˆå¯¹å‡»å‰‘ç¼–æ’è½¯ä»¶çš„ç‰¹æ®Šéœ€æ±‚ï¼Œé‡ç‚¹è§£å†³äº†ä»¥ä¸‹æ ¸å¿ƒé—®é¢˜ï¼š

1. **è£åˆ¤ä½“éªŒ**ï¼šä¸“ä¸ºè§¦æ§ä¼˜åŒ–çš„ç•Œé¢ï¼Œæ”¯æŒæ‰‹åŠ¿æ“ä½œã€æŒ¯åŠ¨åé¦ˆã€å¤§æŒ‰é’®è®¾è®¡
2. **ååŒç¼–è¾‘**ï¼šå®Œæ•´çš„ç¦»çº¿/åœ¨çº¿åŒæ¨¡å¼æ”¯æŒï¼Œæ™ºèƒ½å†²çªæ£€æµ‹ä¸è§£å†³
3. **ä¸“ä¸šæ‰“å°**ï¼šå®¢æˆ·ç«¯PDFç”Ÿæˆï¼Œæ”¯æŒçƒ­æ•æ‰“å°æœºï¼Œç¡®ä¿æ‰“å°è´¨é‡
4. **å®¡è®¡è¿½è¸ª**ï¼šå®Œæ•´çš„å‰ç«¯æ“ä½œæ—¥å¿—ï¼Œæ”¯æŒæ’¤é”€/é‡åšï¼Œç¡®ä¿æ•°æ®å¯è¿½æº¯
5. **å›½é™…åŒ–**ï¼šå®Œæ•´æ”¯æŒå¤šè¯­è¨€ï¼Œç‰¹åˆ«æ˜¯å‡»å‰‘æ³•è¯­æœ¯è¯­
6. **å†²çªè§£å†³**ï¼šå¤šå±‚çº§å†²çªè§£å†³ç­–ç•¥ï¼Œä»è‡ªåŠ¨åˆå¹¶åˆ°äººå·¥å¹²é¢„ï¼Œä¿éšœæ•°æ®ä¸€è‡´æ€§

### ååŒç¼–è¾‘å†²çªè§£å†³ç­–ç•¥äº®ç‚¹ï¼š

1. **æ™ºèƒ½æ¨¡å¼åˆ‡æ¢**ï¼šè‡ªåŠ¨æ£€æµ‹ç½‘ç»œçŠ¶æ€ï¼Œæ— ç¼åˆ‡æ¢åœ¨çº¿/ç¦»çº¿æ¨¡å¼
2. **åˆ†å±‚å†²çªç­–ç•¥**ï¼š
   - **æ¯”èµ›åˆ†æ•°**ï¼šåˆ†å¸ƒå¼é”æœºåˆ¶ï¼Œç¡®ä¿é¡ºåºä¸€è‡´æ€§
   - **å¯¹é˜µè¡¨ç¼–æ’**ï¼šæ“ä½œè½¬æ¢ï¼ˆOTï¼‰ç®—æ³•ï¼Œæ”¯æŒå®æ—¶ååŒ
   - **é€‰æ‰‹ä¿¡æ¯**ï¼šå­—æ®µçº§åˆå¹¶ï¼Œæ™ºèƒ½è§£å†³å­—æ®µå†²çª
   - **è£åˆ¤åˆ†é…**ï¼šä¹è§‚é”+äººå·¥ç¡®è®¤ï¼Œç¡®ä¿è°ƒåº¦å‡†ç¡®æ€§

3. **ç”¨æˆ·ä½“éªŒä¼˜åŒ–**ï¼š
   - å†²çªå¯è§†åŒ–å¯¹æ¯”ï¼Œæ¸…æ™°å±•ç¤ºå˜æ›´å·®å¼‚
   - æ™ºèƒ½è§£å†³å»ºè®®ï¼Œé™ä½ç”¨æˆ·å†³ç­–æˆæœ¬
   - æ‰¹é‡æ“ä½œæ”¯æŒï¼Œæé«˜è§£å†³æ•ˆç‡
   - éé˜»å¡å¼æé†’ï¼Œä¸å½±å“ä¸»è¦å·¥ä½œæµ

4. **æ•°æ®å®‰å…¨ä¿éšœ**ï¼š
   - å®Œæ•´çš„æ“ä½œå®¡è®¡ï¼Œè®°å½•æ‰€æœ‰å†²çªè§£å†³è¿‡ç¨‹
   - ç‰ˆæœ¬å¿«ç…§ä¿å­˜ï¼Œæ”¯æŒæ•°æ®å›æ»š
   - æœ¬åœ°æ•°æ®åŠ å¯†ï¼Œä¿æŠ¤æ•æ„Ÿä¿¡æ¯
   - ç½‘ç»œä¸­æ–­æ¢å¤ï¼Œç¡®ä¿æ•°æ®ä¸ä¸¢å¤±

è¯¥æ¶æ„ç¡®ä¿äº†åœ¨æ¯”èµ›ç°åœºçš„å¤æ‚ç½‘ç»œç¯å¢ƒä¸‹ï¼Œç³»ç»Ÿä»èƒ½ç¨³å®šè¿è¡Œï¼ŒåŒæ—¶ä¿è¯å¤šç”¨æˆ·ååŒç¼–è¾‘çš„æ•°æ®ä¸€è‡´æ€§å’Œå®Œæ•´æ€§ã€‚